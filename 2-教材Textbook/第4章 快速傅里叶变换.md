# **第4章** 快速傅里叶变换

## 4.1 引言

​	必须强调指出：快速傅里叶变换（Fast Fourier Transform，FFT）并不是与DFT不同的另外一种变换，而是为减少DFT计算次数的一种快速有效的算法。为此，要很好理解快速傅里叶变换，首先必须对前面介绍的离散傅里叶变换有充分的理解。

​	傅里叶变换，在一百多年前就已发现，并早已知道频域分析常常比时域分析更优越，不仅简单，且易于分析复杂信号。但用较精确的数字方法，即DFT进行谱分析，在FFT出现前是不切实际的。这是因为DFT计算量太大。直到1965年发现了DFT运算的一种快速方法以后，情况才发生了根本的变化。

​	当时加文（Richard Garwin）在自己的研究中极需要一个计算傅里叶变换的快速方法，而图基（John Wilder Tukey，缩写为J.W.Tukey）正在写有关傅里叶变换的文章，图基概括地对加文介绍了一种方法，它实质上就是后来著名的库利（James William Cooley, 缩写为J.W.Cooley）—图基算法。在加文的迫切要求下，库利很快设计出一个计算机程序。1965年库利—图基在《计算数学》（Mathematics of Computation）杂志上发表了著名的“机器计算复傅里叶级数的一种算法”的文章。后来又有桑德(G.Sande)—图基等快速算法相继出现，人们对库利—图基算法也提出一些改进，从而很快发展和完善了一套高效的运算方法，这就是现在普遍称之为快速傅里叶变换的算法。

​	应该指出，当时电子数字计算机的条件也促成了这个算法的提出。1967年至1968年间FFT的数字硬件就制成了。至此DFT的运算大为简化，运算时间一般可缩短一二个数量级。 因而各个科学技术领域广泛地使用FFT技术，它大大推动了近30年来信号处理技术的进展，现已成为数字信号处理强有力的工具。

​	本章主要研究若干种计算离散傅里叶变换的快速算法，它们是：按时间抽取的FFT算法；按频率抽取的FFT算法；N为复合数的FFT算法；分裂基FFT算法；实序列的FFT算法；线性调频Z变换算法；以及ZFFT算法。

## 4.2直接计算DFT的问题和改善DFT运算效率的基本途径

### **4.2.1.** 直接计算DFT的问题

​			有限列长为$N$的序列$x\left( n \right)$的DFT为

$$
X\left( k \right) = \sum\limits_{n = 0}^{N - 1} {x\left( n \right)W_N^{nk}} \qquad k = 0,1, \ldots  \ldots ,N - 1
\tag{4.2.1}
$$
逆变换为
$$
x\left( n \right) = \frac{1}{N}\sum\limits_{k = 0}^{N - 1} {X\left( k \right)W_N^{ - nk}} \qquad n = 0,1, \cdots N - 1
\tag{4.2.2}
$$
​		二者的差别仅在于${W_N}$的指数符号不同，和差一个比例因子$\frac{1}{N}$。因此，下面我们仅就 (4.2.1) 式算法进行讨论，而 (4.2.2) 式算法的情况与它是极为类似的。

​		一般由于$x\left( n \right)$、$W_N^{nk}$都是复数，$X\left( k \right)$也是复数，因此直接按 (4.2.1) 式计算某个值$X\left( k \right)$需要$N$次$x\left( n \right)W_N^{nk}$形式的复数乘法及$N - 1$次复数加法的运算。$X\left( k \right)$共有$N$个点（*k*从0取到*N*-1），所以完成全部DFT的总计算量则为${N^2}$次复数相乘及$N\left( {N - 1} \right)$次复数相加。我们知道复数运算实际上是由实数运算来完成的， (4.2.1) 式可表示为
$$
\begin{array}{l}
X\left( k \right) = \sum\limits_{n = 0}^{N - 1} {x\left( n \right)W_N^{nk}} \\
{\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt}  = \sum\limits_{n = 0}^{N - 1} {\left[ {{\mathop{\rm Re}\nolimits} x\left( n \right) + j{\mathop{\rm Im}\nolimits} x\left( n \right)} \right]} \left[ {{\mathop{\rm Re}\nolimits} W_N^{kn} + j{\mathop{\rm Im}\nolimits} W_N^{nk}} \right]\\
{\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt}  = \sum\limits_{n = 0}^{N - 1} {\left\{ {\left[ {{\mathop{\rm Re}\nolimits} x(n){\mathop{\rm Re}\nolimits} W_N^{nk} - {\mathop{\rm Im}\nolimits} x(n){\mathop{\rm Im}\nolimits} W_N^{nk}} \right]{\rm{ + }}j\left[ {{\mathop{\rm Re}\nolimits} x(n){\mathop{\rm Im}\nolimits} W_N^{nk} + {\mathop{\rm Im}\nolimits} x(n){\mathop{\rm Re}\nolimits} W_N^{nk}} \right]} \right\}} 
\end{array}
\tag{4.2.3}
$$
​		由上式可见，一个复数乘法须用四个实数乘法和两个实数加法（实部虚部分别相加）来实现。这样，每运算一个$X\left( k \right)$值需要进行$4N$次实数相乘和$2N$ (由复乘所带来的加法) + $2\left( {N - 1} \right)$= 次$2\left( {2N - 1} \right)$实数相加，因此整个DFT运算需要$4{N^2}$次实数相乘和$N \times 2\left( {2N - 1} \right)$次实数相加。

​		上述统计与实际需要的运算是稍有出入的，例如$W_N^0 = 1$实际上就无需乘法运算。但为便于比较，一般不考虑这种个别特例，特别是当*N*很大时，这种特例的影响很小。

​		总之，由上面统计可见，直接计算DFT时，乘法次数与加法次数，都是和${N^2}$成比例的。这样，当*N*很大时，所需的运算工作量非常可观。例如，*N* = 10点的DFT，需要100次复数相乘， 而*N* = 1024时，则需要1,048,576即一百多万次的复乘运算。这对于实时性很强的信号处理 (如雷达信号处理)来说，必将对计算速度有十分苛刻的要求。为此，迫切需要改进对DFT的计算方法，以减少总的运算次数。

### 4.2.2.改善DFT运算效率的基本途径

​		从哪些方面能改进DFT的运算以减少运算工作量呢？仔细考察DFT的运算就会看到：充分利用系数$W_N^{nk}$的下列固有特性，即可改善DFT的运算效率。

​		$W_N^{nk}$的对称性
$$
$W_N^{k(N - n)} = W_N^{ - kn} = {\left( {W_N^{nk}} \right)^*}$
$$
​		$W_N^{nk}$的周期性

$$
$W_N^{kn} = W_N^{k(n + N)} = W_N^{(k + N)n}$
$$


​		**1．**利用**$W_N^{nk}$**的对称性使DFT运算中有些项合并**

​		由于$W_N^{k(N - n)} = {\left( {W_N^{kn}} \right)^*}$，对实、虚部而言则有

$$
\left\{ {\begin{array}{*{20}{c}}
{{\mathop{\rm Re}\nolimits} W_N^{k(N - n)} = {\mathop{\rm Re}\nolimits} W_N^{kn}}\\
{{\mathop{\rm Im}\nolimits} W_N^{k\left( {N - n} \right)} =  - {\mathop{\rm Im}\nolimits} W_N^{kN}}
\end{array}} \right.
$$
​		故(4.2.3)式中的对称项可合并为

$$
\left\{ {\begin{array}{*{20}{c}}
{{\mathop{\rm Re}\nolimits} x\left( n \right){\mathop{\rm Re}\nolimits} W_N^{kn} + {\mathop{\rm Re}\nolimits} x\left( {N - n} \right){\mathop{\rm Re}\nolimits} W_N^{k(N - n)} = \left[ {{\mathop{\rm Re}\nolimits} x\left( n \right) + {\mathop{\rm Re}\nolimits} x\left( {N - n} \right)} \right]{\mathop{\rm Re}\nolimits} W_N^{kn}}\\
{ - {\mathop{\rm Im}\nolimits} x\left( n \right){\mathop{\rm Im}\nolimits} W_N^{kn} - {\mathop{\rm Im}\nolimits} x\left( {N - n} \right){\mathop{\rm Im}\nolimits} W_N^{k(N - n)} =  - \left[ {{\mathop{\rm Im}\nolimits} x\left( n \right) - {\mathop{\rm Im}\nolimits} x\left( {N - n} \right)} \right]{\mathop{\rm Im}\nolimits} W_N^{kn}}
\end{array}} \right.
$$
式中其它各项也可找到类似的合并方法。这样，乘法次数可以减少大约一半。



**2．****利用的周期性和对称性使长序列的DFT分解为更小点数的DFT**

​		前已指出，DFT 的运算量是与${N^2}$成正比的。所以如果一个大点数N的DFT能分解为若干小点数DFT的组合，则显然可达到减少运算工作量的效果。快速傅里叶变换算法正是基于这一基本思想而发展起来的。

快速傅里叶变换算法形式很多，但基本上可分成两大类，即按时间抽取（Decimation in Time，简称DIT) 法和按频率抽取 (Decimation in Frequency，简称DIF) 法。有人把DFT看作是矩阵算法，而把FFT看作是矩阵因式分解处理的结果。实际上这种矩阵因式分解的处理和我们下面所介绍的按时间抽取和按频率抽取的信号流图分解是一致的。 





##     4.3  按时间抽取的FFT算法（库利—图基算法）

### 4.3.1. 算法原理

​		为了讨论方便，设$N = {2^v}$，其中$\nu $为整数。如果不满足这个条件，可以人为地加上若干零值点来达到。这种*N*为2的整数幂的FFT，也称基—2FFT。由定义
$$
X\left( k \right) = \sum\limits_{n = 0}^{N - 1} {x\left( n \right)W_N^{nk}} \qquad k = 0,1, \cdots N - 1
\tag{4.3.1}
$$
​		其中$x\left( n \right)$是列长为$N{\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} \left( {n = 0,1, \cdots N - 1} \right)$的输入序列，把它按$n$的奇偶分成两个子序列
$$
\left\{ {\begin{array}{*{20}{l}}
{x\left( {2r} \right) = {x_1}\left( r \right)\qquad }\\
{x\left( {2r + 1} \right) = {x_2}\left( r \right)}
\end{array}} \right.{\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} r = 0,1, \cdots \frac{N}{2} - 1
\tag{4.3.2}
$$
则(4.3.1)式可化为
$$
\begin{array}{l}
X\left( k \right) = {\mathop{\rm DFT}\nolimits} \left[ {x\left( n \right)} \right] = \mathop {\sum\limits_{n = 0}^{N - 1} {x\left( n \right)W_N^n} }\limits_{n}  + \mathop {\sum\limits_{n = 0}^{N - 1} {x\left( n \right)W_N^n} }\limits_{n} \\
{\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt}  = \sum\limits_{r = 0}^{\frac{N}{2} - 1} {x\left( {2r} \right)W_N^{2rk}}  + \sum\limits_{r = 0}^{\frac{N}{2} - 1} {x\left( {2r + 1} \right)W_N^{\left( {2r + 1} \right)k}} \\
{\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt}  = \sum\limits_{r = 0}^{\frac{N}{2} - 1} {{x_1}\left( r \right){{\left( {W_N^2} \right)}^{rk}}}  + W_N^k\sum\limits_{r = 0}^{\frac{N}{2} - 1} {{x_2}\left( r \right){{\left( {W_N^2} \right)}^{rk}}} 
\end{array}
\tag{4.3.3}
$$
由于$W_N^2 = {{\rm{e}}^{ - j\frac{{2\pi }}{N} \cdot 2}} = {{\rm{e}}^{ - j\frac{{2\pi }}{{\frac{N}{2}}}}} = {W_{\frac{N}{2}}}$，故上式又可表示为
$$
\begin{array}{l}
X\left( k \right) = \sum\limits_{r = 0}^{\frac{N}{2} - 1} {{x_1}\left( r \right)W_{\frac{N}{2}}^{rk}}  + W_N^k\sum\limits_{r = 0}^{\frac{N}{2} - 1} {{x_2}\left( r \right)W_{\frac{N}{2}}^{rk}} \\
{\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt}  = {X_1}\left( k \right) + W_N^k{X_2}\left( k \right)
\end{array}
\tag{4.3.4}
$$
(4.3.4)式中的${X_1}\left( k \right)$及${X_2}\left( k \right)$分别是及${x_1}\left( r \right)$及${x_2}\left( r \right)$的N/2点的DFT
$$
{X_1}\left( k \right) = \sum\limits_{r = 0}^{\frac{N}{2} - 1} {{x_1}\left( r \right)W_{\frac{N}{2}}^{rk}}  = \sum\limits_{r = 0}^{\frac{N}{2} - 1} {x\left( {2r} \right)W_{\frac{N}{2}}^{rk}} 
\tag{4.3.5}
$$

$$
{X_2}\left( k \right) = \sum\limits_{r = 0}^{\frac{N}{2} - 1} {{x_2}\left( r \right)W_{\frac{N}{2}}^{rk}}  = \sum\limits_{r = 0}^{\frac{N}{2} - 1} {x\left( {2r + 1} \right)W_{\frac{N}{2}}^{rk}}
\tag{4.3.6}
$$

​		(4.3.4)式表明了一个*N*点的DFT被分解为两个$\frac{N}{2}$点的DFT,这两个$\frac{N}{2}$点的DFT按照(4.3.4)式又可合成为一个*N*点的DFT。但是这里有一个问题，即${x_1}\left( r \right)$，${x_2}\left( r \right)$的列长为$\frac{N}{2}$，它们的DFT ${X_1}\left( k \right)$，${X_2}\left( k \right)$的点数也是$\frac{N}{2}$，即$k = 0,1, \cdots \frac{N}{2} - 1$，而$X\left( k \right)$却有*N*个点,所以按(4.3.4)式计算得到的只是$X\left( k \right){\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} \left( {k = 0,1, \cdots N - 1} \right)$的前一半项数的结果，要用${X_1}\left( k \right)$${X_2}\left( k \right)$来表达全部的$X\left( k \right)$值还必须应用W系数的周期性，

即
$$
W_{\frac{N}{2}}^{rk} = W_{\frac{N}{2}}^{r\left( {k + \frac{N}{2}} \right)}
$$
这样可得
$$
{X_1}\left( {\frac{N}{2} + k} \right) = \sum\limits_{r = 0}^{\frac{N}{2} - 1} {{x_1}\left( r \right)W_{\frac{N}{2}}^{r\left( {\frac{N}{2} + k} \right)}}  = \sum\limits_{r = 0}^{\frac{N}{2} - 1} {{x_1}\left( r \right)W_{\frac{N}{2}}^{rk}} 
$$
即
$$
{X_1}\left( {\frac{N}{2} + k} \right) = {X_1}\left( k \right)
\tag{4.3.7}
$$
同理可得
$$
{X_2}\left( {\frac{N}{2} + k} \right) = {X_2}\left( k \right)
\tag{4.3.8}
$$
​		(4.3.7)式，(4.3.8)式说明了后半部分*k*值$\left( {\frac{N}{2} \le k \le N - 1} \right)$所对应的${X_1}\left( k \right)$、${X_2}\left( k \right)$则是完全重复了前半部分*k*值$\left( {0 \le k \le \frac{N}{2} - 1} \right)$所对应的值${X_1}\left( k \right)$值和${X_2}\left( k \right)$值，

​		另外又考虑到$W_N^k$的对称性
$$
W_N^{\left( {\frac{N}{2} + k} \right)} = W_N^{\frac{N}{2}} \cdot W_N^k =  - W_N^k
\tag{4.3.9}
$$
​		将(4.3.7)式，(4.3.8)式及(4.3.9)式代入(4.3.4)式中，就可以将$X\left( k \right)$表达为前后两部分。

​	$k=0$到 $\frac{N}{2} - 1$的 $X(k)$的前半部分
$$
X\left( k \right) = {X_1}\left( k \right) + W_N^k{X_2}\left( k \right)\qquad k = 0,1, \cdots ,\frac{N}{2} - 1
\tag{4.3.10}
$$

​		$k = 0$到$\frac{N}{2} - 1$的$X\left( k \right)$的后半部分
$$
\begin{array}{l}
X\left( {\frac{N}{2} + k} \right) = {X_1}\left( {\frac{N}{2} + k} \right) + W_N^{\left( {\frac{N}{2} + k} \right)}{X_2}\left( {\frac{N}{2} + k} \right)\\
{\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt}  = {X_1}\left( k \right) - W_N^k{X_2}\left( k \right)\quad \\
{\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} k = 0,1, \cdots \frac{N}{2} - 1
\end{array}
\tag{4.3.11}
$$
​		由上分析可见，只要求出$\left( {~\frac{N}{2} - 1} \right)$区间内各个整数k值所对应的${X_1}\left( k \right)$和${X_2}\left( k \right)$值，即可求出$(0\ ~N - 1)$区间内的全部$X\left( k \right)$值，这一点恰恰是FFT能大量节省计算的关键所在。

​		(4.3.10)式，(4.3.11)式的运算可用图4.3.1的信号流图符号表示。由于此图外形像个蝴蝶，所以称为蝶式计算结构。图中左面两路为输入，中间以一个小圆表示加减运算，右上路为相加输出，右下路为相减输出。如果在某一支路上信号需要进行相乘运算，则在该支路上标以箭头，将相乘的系数标在箭头旁边。当支路上没有标出箭头及系数时，则该支路的传输比为1。

<img src=".\fig\4.3.1.png" style="zoom:50%;" />

<div align="center">
    <b>图4.3.1 蝶形运算流符号</b>


​		采用这种表示法，可将上述分解过程表示于图4.3.2中。图中所示为$N = {2^3} = 8$的例子。其中$X\left( 0 \right)\ ~X\left( 3 \right)$是由公式(4.3.10)给出的，而$X\left( 4 \right)\ ~X\left( 7 \right)$则是由公式(4.3.11)给出的。

​		由图4.3.2可见，要运算一个蝶形，需一次乘法${X_2}\left( k \right)W_N^k$和二次加(减)法$\left[ {{X_1}\left( k \right) + W_N^k{X_2}\left( k \right)} \right]$,$\left[ {{X_1}\left( k \right) - W_N^k{X_2}\left( k \right)} \right]$。据此，一个*N*点的DFT分解为$\frac{N}{2}$两个点的DFT(设此$\frac{N}{2}$点的DFT是由直接计算得到的，下面将可看到,它们还可被继续分解，则各需${\left( {\frac{N}{2}} \right)^2}$次复乘和$\frac{N}{2}\left( {\frac{N}{2} - 1} \right)$次复加，两个$\frac{N}{2}$ DFT则需要$2{\left( {\frac{N}{2}} \right)^2} = \frac{{{N^2}}}{2}$次复乘和$2 \times \frac{N}{2}\left( {\frac{N}{2} - 1} \right) = N\left( {\frac{N}{2} - 1} \right)$次复加，将两个$\frac{N}{2}$点的DFT合成为*N*点的DFT 时，需要再进行$\frac{N}{2}$个蝶形运算，即还需要$\frac{N}{2}$次乘法和次$2 \times \frac{N}{2} = N$加法运算。因此通过这样分解后,计算全部$X\left( k \right)$共需要$\frac{{{N^2}}}{2} + \frac{N}{2} \approx \frac{{{N^2}}}{2}$次复乘和$N(N/2 - 1) + N = {N^2}/2$次复加。前已指出，直接计算*N*点DFT需要${N^2}$次复乘和$N\left( {N - 1} \right)$次复加。由此可见，仅仅作了一次分解，即可使计算量差不多节省了一半。

<img src=".\fig\4.3.2.png" style="zoom:50%;" />

<div align="center">
    <b>图4.3.2 按时间抽取将一个N点DFT分解为2个$\frac{N}{2}$点DFT（N=8）</b>


​		既然这样分解是有效的，由于$N = {2^v}$, $\frac{N}{2}$仍然是偶数，所以可以进一步把每个$\frac{N}{2}$点子序列再按其奇偶部分分解为两个$\frac{N}{4}$点子序列。

​		对于$N = 8$点的DFT的例子，输入序列$x\left( n \right)$按偶数点和奇数点进行第一次分解后成为：

| ［偶序列］                                     | ［奇序列］                                         |
| ---------------------------------------------- | -------------------------------------------------- |
| $x\left( {2r} \right) = {x_1}\left( r \right)$ | $x\left( {2r + 1} \right) = {x_2}\left( r \right)$ |
| $r = 0,1,2, \cdots N/2 - 1$                    | $r = 0,1,2, \cdots N/2 - 1$                        |
| ${x_1}\left( 0 \right) = x\left( 0 \right)$    | ${x_2}\left( 0 \right) = x\left( 1 \right)$        |
| ${x_1}\left( 1 \right) = x\left( 2 \right)$    | ${x_2}\left( 1 \right) = x\left( 3 \right)$        |
| ${x_1}\left( 2 \right) = x\left( 4 \right)$    | ${x_2}\left( 2 \right) = x\left( 5 \right)$        |
| ${x_1}\left( 3 \right) = x\left( 6 \right)$    | ${x_2}\left( 3 \right) = x\left( 7 \right)$        |

现在需要进一步把每个$\frac{N}{2}$点子序列按其奇偶部分分解为两个$\frac{N}{4}$点子序列，设用以下符号区分奇偶数序列：

| ［奇序列中的偶数序列］                                       | ［奇序列中的奇数序列］                                       |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| ${x_1}\left( {2l} \right) = {x_3}\left( l \right)$           | ${x_1}\left( {2l + 1} \right) = {x_4}\left( l \right)$       |
| $l = 0,1, \cdots ,N/4 - 1$                                   | $l = 0,1, \cdots ,N/4 - 1$                                   |
| ${x_3}\left( 0 \right) = {x_1}\left( 0 \right) = x\left( 0 \right)$ | ${x_4}\left( 0 \right) = {x_1}\left( 1 \right) = x\left( 2 \right)$ |
| ${x_3}\left( 1 \right) = {x_1}\left( 2 \right) = x\left( 4 \right)$ | ${x_4}\left( 1 \right) = {x_1}\left( 3 \right) = x\left( 6 \right)$ |



| ［奇序列中的偶数序列］                                       | ［奇序列中的奇数序列］                                       |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| $ {x_2}\left( {2l} \right) = {x_5}\left( l \right)$          | ${x_2}\left( {2l + 1} \right) = {x_6}\left( l \right)$       |
| $l = 0,1, \cdots ,N/4 - 1$                                   | $l = 0,1, \cdots ,N/4 - 1$                                   |
| ${x_5}\left( 0 \right) = {x_2}\left( 0 \right) = x\left( 1 \right)$ | ${x_6}\left( 0 \right) = {x_2}\left( 1 \right) = x\left( 3 \right)$ |
| ${x_5}\left( 1 \right) = {x_2}\left( 2 \right) = x\left( 5 \right)$ | ${x_6}\left( 1 \right) = {x_2}\left( 3 \right) = x\left( 7 \right)$ |

​		和第一次分解相同，将序列按奇偶两部分进行第二次分解后，可得

上面式中
$$
\begin{array}{l}
{X_1}\left( k \right) = \sum\limits_{l = 0}^{\frac{N}{4} - 1} {{x_1}\left( {2l} \right)W_{\frac{N}{2}}^{2lk}}  + \sum\limits_{l = 0}^{\frac{N}{4} - 1} {{x_1}\left( {2l + 1} \right)W_{\frac{N}{2}}^{\left( {2l + 1} \right)k}} \\
{\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt}  = \sum\limits_{l = 0}^{\frac{N}{4} - 1} {{x_3}} (l)W_{\frac{N}{4}}^{lk} + W_{\frac{N}{2}}^k\sum\limits_{l = 0}^{\frac{N}{4} - 1} {{x_4}} (l)W_{\frac{N}{4}}^{lk}\\
{\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt}  = {X_3}(k) + W_{\frac{N}{2}}^k{X_4}(k){\kern 1pt} 
\end{array}
\tag{$k = 0,1, \cdots \frac{N}{4} - 1$}
$$
​		而
$$
{X_1}\left( {\frac{N}{4} + k} \right) = {X_3}\left( k \right) - W_{\frac{N}{2}}^k{X_4}\left( k \right){\kern 1pt}
\tag{$k = 0,1, \cdots \frac{N}{4} - 1$}
$$
​		上面式中
$$
{X_3}\left( k \right) = \sum\limits_{l = 0}^{\frac{N}{4} - 1} {{x_3}\left( l \right)W_{\frac{N}{4}}^{lk}}
\tag{4.3.12}
$$

$$
{X_4}\left( k \right) = \sum\limits_{l = 0}^{\frac{N}{4} - 1} {{x_4}\left( l \right)W_{\frac{N}{4}}^{lk}}
\tag{4.3.13}
$$

​		流图4.3.3给出*N* = 4时，由两个$\frac{N}{4}$点的DFT组合成一个$\frac{N}{{\rm{2}}}$的DFT。

<img src=".\fig\4.3.3.png" style="zoom:50%;" />

<div align="center">
    <b>图4.3.3由两个*N*/4点DFT组合成*N*/2点DFT</b>


​		${X_2}\left( k \right)$也可进行同样分解
$$
\begin{array}{l}
{X_2}\left( k \right) = \sum\limits_{l = 0}^{\frac{N}{4} - 1} {{x_2}\left( {2l} \right)W_{\frac{N}{2}}^{2lk}}  + \sum\limits_{l = 0}^{\frac{N}{4} - 1} {{x_2}\left( {2l + 1} \right)W_{\frac{N}{2}}^{\left( {2l + 1} \right)k}} \\
{\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt}  = \sum\limits_{l = 0}^{\frac{N}{4} - 1} {{x_5}} (l)W_{\frac{N}{4}}^{lk} + W_{\frac{N}{2}}^k\sum\limits_{l = 0}^{\frac{N}{4} - 1} {{x_6}} (l)W_{\frac{N}{4}}^{lk}\\
{\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt}  = {X_5}(k) + W_{\frac{N}{2}}^k{X_6}(k){\kern 1pt} {\kern 1pt} 
\end{array}
\tag{$k = 0,1, \cdots \frac{N}{4} - 1$}
$$
​		而
$$
{X_2}\left( {\frac{N}{4} + k} \right) = {X_5}\left( k \right) - W_{\frac{N}{2}}^k{X_6}\left( k \right)
\tag{$k = 0,1, \cdots \frac{N}{4} - 1$}
$$
​		上面式中
$$
{X_5}\left( k \right) = \sum\limits_{l = 0}^{\frac{N}{4} - 1} {{x_5}\left( l \right)W_{\frac{N}{4}}^{lk}} 
\tag{4.3.14}
$$

$$
{X_6}\left( k \right) = \sum\limits_{l = 0}^{\frac{N}{4} - 1} {{x_6}\left( l \right)W_{\frac{N}{4}}^{lk}}
\tag{4.3.15}
$$

​		将系数统一为$W_{\frac{N}{2}}^k = W_N^{2k}$。这样一个8点的DFT就可分解为四个$\frac{N}{4}$点的DFT，先作$\frac{N}{4}$点的 DFT计算，再令相应的两个$\frac{N}{4}$点DFT的结果，合成$\frac{N}{2}$点的DFT，从而得到${X_1}\left( k \right)$，${X_2}\left( k \right)$。最后按(4.3.10)式，(4.3.11)式组合成*N*点的DFT，其流图如图4.3.4所示。

<img src=".\fig\4.3.4.png" style="zoom:50%;" />

<div align="center">
    <b>图4.3.4 按时间抽取将一个N点DFT分解为四个$\frac{N}{4}$点DFT(N=8)</b>


​		根据前面同样分析可以知道，利用四个$\frac{N}{4}$点DFT及两次组合来计算*N*点DFT，比仅用一次分解组合方式时的计算量又减少了约一半。

​		对于*N* = 8点的DFT，经过两次分解后，最后剩下的是四个$\frac{N}{4} = 2$点的DFT，即${X_3}\left( k \right)$，${X_4}\left( k \right)$，${X_5}\left( k \right)$，${X_6}\left( k \right)$，*k* =0,1。由(4.3.12)式至(4.3.15)式可分别将它们计算出来，例如，由(4.3.12)式可得出
$$
{X_3}\left( k \right) = \sum\limits_{l = 0}^{\frac{N}{4} - 1} {{x_3}\left( l \right)W_{\frac{N}{4}}^{lk}}  = \sum\limits_{l = 0}^1 {{x_3}\left( l \right)W_{\frac{N}{4}}^{lk}} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} k = 0,1
$$
即
$$
\left\{ {\begin{array}{*{20}{c}}
{{X_3}\left( 0 \right) = x\left( 0 \right) + W_2^0x\left( 4 \right) = x\left( 0 \right) + W_N^0x\left( 4 \right)}\\
{{X_3}\left( 1 \right) = x\left( 0 \right) + W_2^1x\left( 4 \right) = x\left( 0 \right) - W_N^0x\left( 4 \right)}
\end{array}} \right.
$$
注意，上式中$W_2^1 = {e^{ - j\pi }} =  - 1$，而$W_N^0 = 1$，故计算上式不需乘法。同时注意${X_3}\left( l \right)$和$x\left( n \right)$的对应关系。

​		${X_4}\left( k \right),{X_5}\left( k \right),{X_6}\left( k \right)$可类似求出。这些两点DFT可用一个蝶形结表示。这样一个按时间抽取运算的完整的8点DFT流图如图4.3.5所示。

<img src=".\fig\4.3.5.png" style="zoom:50%;" />

<div align="center">
    <b>图4.3.5 N=8的按时间抽取法FFT运算流图</b>


​		推广到点数$N = {2^v}$的一般情况，不难看出，第*m*次分解的结果是由${2^m}$个$\frac{N}{{{2^m}}}$的DFT两两组成共${2^{m - 1}}$个$\frac{N}{{{2^{m - 1}}}}$点的DFT。由于$N = {2^v}$，通过$\nu  = {\log _2}N$次分解后，最终达到了$\frac{N}{2}$个两点DFT的运算，从而构成了由$x\left( n \right)$的$X\left( k \right)$的*v*级运算过程，如图4.3.6所示。

<img src=".\fig\4.3.6.png" style="zoom:50%;" />

<div align="center">
    <b>图4.3.6 N点基-2FFT的v级迭代过程($N = {2^v}$)</b>
​		这种方法，由于每一步分解都是按每级输入序列在时间上的次序是属于偶数还是奇数来分解为两个更短的子序列，所以称为“按时间抽取法”。

### 4.3.2. 按时间抽取的FFT算法与直接计算DFT运算量的比较

​		由前面介绍的按时间抽取的FFT运算流图可见，每一级都由$\frac{N}{2}$个蝶形运算构成。因此 每一级运算都需要$\frac{N}{2}$次复乘和$N$复加(每个结加减各一次)。这样*v*级运算总共需要

复乘数
$$
{m_F} = \frac{N}{2}\nu  = \frac{N}{2}{\log _2}N
\tag{4.3.16}
$$
复加数
$$
{a_F} = N\nu  = N{\log _2}N
\tag{4.3.17}
$$
实际计算量和这个数字稍有出入，因为$W_N^0 = 1$，由流图可见，这种情况共有$\left( {1 + 2 + 4 +  \cdots  + {2^{l - 1}}} \right) = \sum\limits_{n = 0}^{l - 1} {{2^n}}  = {2^l} - 1 = N - 1$次，$W_N^{\frac{N}{2}} =  - 1,{\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} W_N^{ \pm \frac{N}{4}} =  \mp j$，这几个系数是都不用乘法运算的，但这种情况在直接计算DFT中也是有的，且当*N*较大时，这些影响也较小。所以为了统一作比较我们不考虑以上特例。

综上所述，可以得出如下结论:按时间抽取法所需的复乘数和复加数都是与*N*log2*N*成正比的，而直接计算DFT时所需的复乘数与复加数则都是与*N*2成正比，复乘数${m_d} = {N^2}$，复加数${a_d} = N(N - 1) \approx {N^2}$。表4.3.1列出了不同*N*值时的FFT算法与直接计算DFT的运算量的比较。计算时间是与计算次数成正比的，所以由表中可见，当W较大时，按时间抽取法将比直接法快一、二个数量级之多。例如N=2048时,如果直接运算需要三个小时，釆用FFT则只要不到一分钟就完成了。这样的速度增益使得用FFT解决信号处理问题成为实际可能，由此 可见FFT算法的重大意义。

<div align="center">
    <b>表4.3.1.FFT算法与直接算法的比较</b>
| *N*  | *N*2    | *N*log2*N* | *N*2*/N*log2*N* |
| ---- | ------- | ---------- | --------------- |
| 2    | 4       | 2          | 2.0             |
| 4    | 16      | 8          | 2.0             |
| 8    | 64      | 24         | 2.7             |
| 16   | 256     | 64         | 4.0             |
| 32   | 1024    | 160        | 6.4             |
| 64   | 4096    | 384        | 10.7            |
| 128  | 16384   | 896        | 18.3            |
| 256  | 65536   | 2048       | 32.0            |
| 512  | 262144  | 4608       | 56.9            |
| 1024 | 1048576 | 10240      | 102.4           |
| 2048 | 4194304 | 22528      | 186.2           |

​		由于数字计算机进行乘法所需时间比加法多得多，如果计算时间只考虑与乘法次数成正比，则直接算法对FFT算法的计算时间之比有下列近似关系
$$
\frac{{{N^2}}}{{N\nu /2}} = \frac{{2N}}{\nu } = \frac{{2N}}{{{{\log }_2}N}}
\tag{4.3.18}
$$
图4.3.7示出的FFT算法和直接算法所需运算量与点数*N*的关系曲线，使我们更加直观的看出了 FFT算法的优越性，特別是点数*N*越大时，优点更加突出。

<img src=".\fig\4.3.7.png" style="zoom:50%;" />

<div align="center">
    <b>图4.3.7直接计算法与FFT算法所需乘法次数的比较曲线</b>


### 4.3.3.  按时间抽取的FFT算法的特点

​		为了根据前面讨论的DIT基-2FFT算法原理，能得出任何点的FFT信号流图，并进而得出FFT计算程序流程图，我们必须总结出按时间抽取法分解过程的规律。

<img src=".\fig\4.3.8.png" style="zoom:50%;" />

<div align="center">
    <b>图4.3.8 时间抽取法蝶形运算结构</b>


1．原位运算

​		由所述算法原理及图4.3.5的*N* = 8的信号流图，我们首先发现，FFT的每级(列)计算都是由*N*个复数据经$\frac{N}{{\rm{2}}}$个蝶形运算变成了另外*N*个复数据。每一蝶形运算结构完成下述基本迭代运算 
$$
\left\{ {\begin{array}{*{20}{c}}
{{A_m}\left( i \right) = {A_{m - 1}}\left( i \right) + {A_{m - 1}}\left( j \right)W_N^k}\\
{{A_m}\left( j \right) = {A_{m - 1}}\left( i \right) - {A_{m - 1}}\left( j \right)W_N^k}
\end{array}} \right.
\tag{4.3.19}
$$
式中*m*表示第*m*列迭代，*i*，*j*为数据所在的行数。上式的运算如图4-8所示，由一次复乘运算和一次加减运算构成。

​		由信号流图4.3.5可见，任何两个节点*i*和*j*的节点变量进行蝶型运算后，其结果为下一列的*i* , *j*两点的节点变量，而和其它节点变量无关。因此，如果所有的$W_N^k$的值已预先置存，那末除了运算的工作单元之外，只用*N*个寄存器就够了。因为每个蝶型运算是由两个寄存器中取出数据，而计算结果仍存放到此二寄存器中，该寄存单元中原存的内容，一经取用即可抹去，不影响以后的计算。每列的$\frac{N}{{\rm{2}}}$个蝶型运算全作完以后再开始下一列的蝶算，这样*N*个寄存器分别存储了每列*N*个不同行的节点变量。每计算完一列，各寄存器中变量所对应的节点沿横行向右偏移一列。由此可见，每列运算均可在原位(in-place)进行，这种原位运算的结构可以节省存储单元， 降低设备成本。

2.**输人序列的序号及整序规律**

​		由图4.3.5可见，当按原位进行计算时，FFT输出端的*X*(*k*) 的次序正好是顺序排列的，即*X*(0)，*X*(1),…*X*(7)。但这时输入*x*(*n*)却不能按自然顺序存入存储单元，而是按*x*(0), *x*(4), *x*(2),*x*(6)…的顺序存入存储单元，因而是乱序的。这就使得运算时取数据的地址编排“混乱无序”。

1) 造成乱序的原因

​		乱序的原因是由按时间抽取进行FFT运算的原理造成的。回顾得到流图4.3.5的过程，序列$x\left( n \right)$首先分成偶序列和奇序列，在图4.3.2的上半部分为偶序列$x\left( 0 \right)$，$x\left( 2 \right)$，$x\left( 4 \right)$，$x\left( 6 \right)$，用二进制数表示则为$x\left( {000} \right)$，$x\left( {010} \right)$，$x\left( {100} \right)$，$x\left( {110} \right)$。下部分为奇序列$x\left( 1 \right)$，$x\left( 3 \right)$，$x\left( 5 \right)$，$x\left( 7 \right)$用二进制数表示则为$x\left( {001} \right)$，$x\left( {011} \right)$，$x\left( {101} \right)$，$x\left( {111} \right)$。输入序列的这种划分可以通过研究二进制数表示指标*n*（即${n_2}{n_1}{n_0}$）的最小有效位${n_0}$看出。如果最小有效位为0,则序列相当于偶序列，出现在$x\left( r \right)$的上半部分。如果最小有效位为1，则序列相当于奇序列，出现在$x\left( r \right)$的下半部分。接着，偶、奇子序列又按其排列顺序分为偶、奇序列。例如，将偶子序列再分成偶、奇序列后，则其偶序列为$x\left( 0 \right)\left[ {x\left( {000} \right)} \right]$,$x\left( 4 \right)\left[ {x\left( {100} \right)} \right]$，奇序列为$x\left( 2 \right)\left[ {x\left( {010} \right)} \right]$,$x\left( 6 \right)\left[ {x\left( {110} \right)} \right]$，而且每次分解总是将偶列放在上，奇列放在下。这也可以通过研究指标*n*的次小有效位(${n_1}$)看出。如果次小有效位${n_1}$为0，则序列是这个子序列的偶数项。如果次小有效位${n_1}$为1，则序列是这个子序列的奇数项。对原来的奇子序列可进行同样的处理。重复这个过程直到列长为1的*N*个子序列。对于*N* = 8的情况，最后得到序列的顺序为$x\left( 0 \right)\left[ {x\left( {000} \right)} \right]$,$x\left( 4 \right)\left[ {x\left( {100} \right)} \right]$,$x\left( 2 \right)\left[ {x\left( {010} \right)} \right]$,$x\left( 6 \right)\left[ {x\left( {110} \right)} \right]$,$x\left( 1 \right)\left[ {x\left( {001} \right)} \right]$,$x\left( 5 \right)\left[ {x\left( {101} \right)} \right]$,$x\left( 3 \right)\left[ {x\left( {011} \right)} \right]$,$x\left( 7 \right)\left[ {x\left( {111} \right)} \right]$。这种分成偶数和奇数子序列的情况，如图4.3.9所示，称为树状图。这就是为什么按时间抽取的FFT算法输入序列的序数成为乱序的原因。

<img src=".\fig\4.3.9.png" style="zoom:50%;" />

<div align="center">
    <b>图 4.3.9 二进制反序的树状图</b>


​		上述讨论，对$N = {2^v}$的一般情况完全适合。

2) 整序的规律

​		在实际运算中，直接将输入数据$x\left( n \right)$按原位运算所要求的“乱序”存放是很不方便的。因此总是先按自然顺序将输人序列存入存储单元，再通过变址运算将自然顺序变换成按时间抽取的FFT算法要求的顺序。变址的过程可以用程序安排加以实现，称为“整序”或“重排”。

​		上面分析的输入序列“乱序”的原因，已经为我们指出了整序的规律，这个规律就是如果输入序列的序号$n$用二进制数，例如${n_2}{n_1}{n_0}$表示，则其反序二进制数$\hat n$就是${n_0}{n_1}{n_2}$，这样原来在自然顺序时应该放$x\left( n \right)$的存储单元，现在放着的是$x\left( {\hat n} \right)$。例如时$N = 8$，$x\left( 1 \right)$的序数$n = 1$，它的二进制数是001，反序二进制数是100，即$\hat n = 4$，所以在放$x\left( {001} \right)$的单元现在应放入$x\left( {100} \right)$。表4.3.2列出了$N = 8$时的顺序二进制数以及相应的反序二进制数。

 <div align="center">
    <b>表4.3.2顺序和反序二进制数次序</b>


| 序号 | 二进制数 | 反序二进制数 | 反序序号 |
| ---- | -------- | ------------ | -------- |
| 0    | 000      | 000          | 0        |
| 1    | 001      | 100          | 4        |
| 2    | 010      | 010          | 2        |
| 3    | 011      | 110          | 6        |
| 4    | 100      | 001          | 1        |
| 5    | 101      | 101          | 5        |
| 6    | 110      | 011          | 3        |
| 7    | 111      | 111          | 7        |

​		将按自然顺序存放在存储单元中的数据,调换成FFT原位运算所要求的反序的变址功能，如图4.3.10所示。当$n = \hat n$时，数据不必调换，当时$n \ne \hat n$必须将原来存放数据$x\left( n \right)$的存储单元内调入数据$x\left( {\hat n} \right)$，而 将$x\left( {\hat n} \right)$存放的单元内调入$x\left( n \right)$。为避免再次考虑时面已调换过的数据，保证调换只进行一次(否则又变回原状)，我们只要检查一下$\hat n$是否比$n$小，假若$\hat n$比$n$小，则意味着在前边已与互$x\left( {\hat n} \right)$相调换过。只有当$n > \hat n$时，才将原存放$x\left( n \right)$及存放$x\left( {\hat n} \right)$的存储单元内的内容互换。经过上述变址运算以后所得到数据顺序正是输入所要求的顺序。与图4.3.5的输入顺序对照，不难看出上述整序规律是正确的。

<img src=".\fig\4.3.10.png" style="zoom:50%;" />

<div align="center">
    <b>图4.3.10输入序列的变址处理</b>


3．各类蝶形运算两个点相距的“距离”及**$W_N^k$**的变化规律

​		以图4.3.5的8点FFT为例，第一列蝶形运算只有一种类型：系数为$W_8^0 = 1$，参加运算的两个数据点间距为1。第二列有2种类型的蝶形运算：系数分别是$W_8^0,W_8^2$**，**参加蝶形运算的两个数据点的间距等于2。第三列有4种类型的蝶形运算：系数分别是叫$W_8^0,W_8^1,W_8^2,W_8^3$**，**参加蝶形运算的两个数据点间的间距等于4。可见，每列的蝶形类型比前一列增加一倍，参加蝶形运算的两个数据点的间距也增大一倍。最后一列系数用得最多，为4个，即$W_8^0,W_8^1,W_8^2,W_8^3$**，**而前一列只用到它偶序号的那一半，即$W_8^0,W_8^2$**，**第一列只有一个系数即$W_8^0$**。**

​		上述结论可推广到$N = {2^v}$的一般情况。规律是第一列只有一种类型的蝶形运算，系数是*$W_N^0$*。**以后每列的蝶形类型，比前一列增加一倍，到第$v$列是$\frac{N}{2}$个蝶形类型，系数是$W_N^0,W_N^1,...W_N^{\frac{N}{2} - 1}$**,共$\frac{N}{2}$个。由后向前每推进一列，则用上述系数中偶数序号的那一半,例如第列$v - 1$的系数为$W_N^0,W_N^2,W_N^4...$。参加蝶形运算的两个数据点的间距，则是最末一级最大，其值为$\frac{N}{2}$，向前每推进一列，间距减少一半。

### 4.3.4. 按时间抽取的FFT算法的若干变体

​		显然，对于任何流图，只要保持各节点所连的支路及其传输系数不变，则不论节点位置怎么排列所得流图总是等效的，最后所得结果$x\left( n \right)$都是的离散傅里叶变换的正确结果，只是数据的提取和存放的次序不同而已。根据这种设想可得按时间抽取的FFT算法的若干变体。

​		将图4.3.5中跟$x\left( 4 \right)$水平相邻的所有节点和跟$x\left( 1 \right)$水平相邻的所有节点位置对调，再将与$x\left( 6 \right)$水平相邻的所有节点和与$x\left( 3 \right)$水平相邻的所有节点对调，其余诸节点保持不变，则可得图4.3.11。图4.3.5与图4.3.11二者都通过相同的蝶形运算来实现，运算量也一样。不同之点主要有二：第一是数据存放方式不同，图4.3.5的输入序列是反序，输出是自然顺序，而图4.3.11则正好相反。第二是取用系数的顺序不同，图4.3.5的最后一列是按的顺序取用系数的，而图4.3.11的最后一列是按的顺序取用系数。图4.3.11的流图相当于最初由库利和图基给出的时间抽取法。这种算法取用系数的特点是前一列所用的系数，正好是后一列所用系数的前一半。在用硬件实现FFT时常用这种变体。

<img src=".\fig\4.3.11.png" style="zoom:50%;" />

<div align="center">
    <b>图4.3.11 输入是自然顺序而输出是反序的流图</b>


​		再对图4.3.11的后两列节点作位置调整，又可得图4.3.12流图。它的优点是输入输出都是顺序，无需数据重排。但它却失掉了“原位运算”的性质。这样一来，为变换$N$点数据，至少需要$2N$个复数存储单元。在信号处理中，内存一般是比较紧张的，而对输入数据整序并不困难。因此，图4.3.12的变体用得不多，不过因为无须整序有时为了争取速度，在专用硬件实现中也有用这种变体的。

<img src=".\fig\4.3.12.png" style="zoom:50%;" />

<div align="center">
    <b>图4.3.12 输入和输出都是自然顺序的流图</b>


​		在实现图4.3.5，图4.3.11，图4.3.12所描述的计算中，各列计算的几何结构都是不同的。例如.按图4.3.5,由输入数据计算第一列时，每个蝶形的输入是存放在相邻存储位置上的。当从第一列计算第二列时，蝶形的输入隔开两个存储位置，而从第二列计算第三列时蝶形运算的输入隔开四个存储位置…以此下去，最后第$v$列的间隔为$\frac{N}{2}$。图4.3.11，图4.3.12各列计算的几何结构也是不同的。

​		对以上各流图进行各列计算时，从各存储器的取数和存数的顺序都是不同的，因此必须采用有随机存取能力的存储器。在没有随机存储器时，可将流图各节点位置调整成图4.3.13所示的形式。此图又回到了输入是反序，输出是自然顺序的情况，但它每列计算的几何结构却是完全一样的，只是列与列之间的支路传输比是改变的。因此，计算每列时，从存储器取数和存数的顺序都是一样的。

<img src=".\fig\4.3.13.png" style="zoom:50%;" />

<div align="center">
    <b>图4.3.13 输入为反序，输出为自然顺序的恒定几何结构流图</b>


​		图4.3.13流图最初是由辛格尔顿(Singleton)给出的按时间抽取算法，因为控制方式简单，有些硬件实现采用这种变体。

​		图4.3.14是各列计算几何结构恒定的另一流图，与图4.3.13不同的仅是这里输入为自然顺序，而输出则是反序。

<img src=".\fig\4.3.14.png" style="zoom:50%;" />

<div align="center">
    <b>图4.3.14 输入为自然顺序，输出为反序的恒定几何结构流图</b>




##               4.4 按频率抽取的FFT算法（桑德—图基算法）

与按时间抽取的FFT算法相对应，还存在另一种称为按频率抽取的算法。这个方法不是将序列$x\left( n \right)$分解，而是将代表频域的输出序列$X\left( k \right)$(它也具有$N$点)按其顺序是属于偶数还是奇数分解为越来越短的序列。这是桑德1966年提出的。

### 4.4.1.    算法原理

为了方便，仍讨论$x\left( n \right)$的列长\[N = {2^v}\]，$v$为整数的情况。先将$x\left( n \right)$按$n$的顺序分成前后两半（注意，这里是按前后而不是奇偶），由后面分析可见$X\left( k \right)$则是按奇，偶分组。

前半子序列 $x(n){\rm{    }}\qquad 0 \le n \le \frac{N}{2} - 1$

后半子序列 $x\left( {n + \frac{N}{2}} \right)\qquad 0 \le n \le \frac{N}{2} - 1$

则由定义

 $\begin{array}{l}
X(k) = \sum\limits_{n = 0}^{N - 1} {x\left( n \right)W_N^{nk}}  = \sum\limits_{n = 0}^{\frac{N}{2} - 1} {x\left( n \right)W_N^{nk}}  + \sum\limits_{n = \frac{N}{2}}^{N - 1} {x\left( n \right)W_N^{nk}} \\
{\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt}  = \sum\limits_{n = 0}^{\frac{N}{2} - 1} {x\left( n \right)W_N^{nk}}  + \sum\limits_{n = 0}^{\frac{N}{2} - 1} {x\left( {n + \frac{N}{2}} \right)W_N^{\left( {n + \frac{N}{2}} \right)k}} \\
{\rm{                       }}{\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} k = 0,1,...N - 1
\end{array}$  (4.4.1)

注意，由于${W_N} = {{\rm{e}}^{ - i\frac{{2\pi }}{N}}} \ne {W_{\frac{N}{2}}}$，所以式中的两个和式并不代表$\frac{N}{2}$点的DFT。因为$W_N^{\frac{N}{2}} = {{\rm{e}}^{ - j\frac{{2\pi }}{N}\frac{N}{2}}} = {{\rm{e}}^{ - j\pi }} =  - 1$，$W_N^{\left( {\frac{N}{2}} \right)k} = {\left( { - 1} \right)^k}$，则(4.4.1)式可写为

 $\begin{array}{l}
X(k) = \sum\limits_{n = 0}^{\frac{N}{2} - 1} {\left[ {x\left( n \right) + W_N^{\frac{N}{2}k}x\left( {n + \frac{N}{2}} \right)} \right]} W_N^{nk}\\
{\rm{        }} = \sum\limits_{n = 0}^{\frac{N}{2} - 1} {\left[ {x\left( n \right) + {{\left( { - 1} \right)}^k}x\left( {n + \frac{N}{2}} \right)} \right]} W_N^{nk}\\
{\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} \qquad k = 0,1, \cdots N - 1
\end{array}$  (4.4.2)

由$W_N^{\left( {\frac{N}{2}} \right)k} = {\left( { - 1} \right)^k}$可以看出，当$k$为偶数时，${\left( { - 1} \right)^k} = 1$，$k$为奇数时，${\left( { - 1} \right)^k} =  - 1$。为此按$k$的奇偶可将$X\left( k \right)$分为两部分，令

$k = 2r{\rm{ }} k = 2r + 1,\quad r = 0,1,2, \cdots \frac{N}{2} - 1$

则

 $\begin{array}{l}
X\left( {2r} \right) = \sum\limits_{n = 0}^{\frac{N}{2} - 1} {\left[ {x\left( n \right) + x\left( {n + \frac{N}{2}} \right)} \right]W_N^{2rn}} \\
{\rm{          }} = \sum\limits_{n = 0}^{\frac{N}{2} - 1} {\left[ {x\left( n \right) + x\left( {n + \frac{N}{2}} \right)} \right]W_{\frac{N}{2}}^{rn}} 
\end{array}$  (4.4.3)

 $\begin{array}{l}
X\left( {2r + 1} \right) = \sum\limits_{n = 0}^{\frac{N}{2} - 1} {\left[ {x\left( n \right) - x\left( {n + \frac{N}{2}} \right)} \right]W_N^{\left( {2r + 1} \right)n}} \\
{\rm{          }}{\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt}  = \sum\limits_{n = 0}^{\frac{N}{2} - 1} {\left[ {x\left( n \right) - x\left( {n + \frac{N}{2}} \right)} \right]W_N^nW_{\frac{N}{2}}^{rn}} 
\end{array}$  (4.4.4)

(4.4.3)式为输入序列前一半和后一半之和的$\frac{N}{2}$点离散博里叶变换；(4.4.4)式为输入序列的前一半和后一半之差与$W_N^n$之积的$\frac{N}{2}$点离散傅里叶变换。令

 $\left\{ {\begin{array}{*{20}{c}}
{{x_1}\left( n \right) = x\left( n \right) + x\left( {n + \frac{N}{2}} \right)}\\
{{x_2}\left( n \right) = \left[ {x\left( n \right) - x\left( {n + \frac{N}{2}} \right)} \right]W_N^n}
\end{array}} \right.\qquad n = 0,1, \cdots \frac{N}{2} - 1$  (4.4.5)

则

 $\left\{ {\begin{array}{*{20}{c}}
{X\left( {2r} \right) = \sum\limits_{n = 0}^{\frac{N}{2} - 1} {{x_1}\left( n \right)W_{\frac{N}{2}}^{nr}} }\\
{X\left( {2r + 1} \right) = \sum\limits_{n = 0}^{\frac{N}{2} - 1} {{x_2}\left( n \right)W_{\frac{N}{2}}^{nr}} }
\end{array}} \right.{\rm{          }}r = 0,1, \cdots \frac{N}{2} - 1$  (4.4.6)

(4.4.5)式的运算关系可以用图4.4.1所示的蝶形运算来表示。这样，我们就将一$N$点FT按频率$k$的奇偶分解为两个新序列的$\frac{N}{2}$点的DFT。在$N = 8$时,上述的分解过程如图4.4.3所示。

<img src=".\fig\4.4.1.png" style="zoom:80%;" />

图4.4.1频率抽取法的蝶形运算

与时间抽取法的推演过程一样，由于 $N = {2^v}$，$\frac{N}{2}$仍是一个偶数。因此可以将$\frac{N}{2}$点的DFT的输出再分解为偶数组与奇数组。这样就将$\frac{N}{2}$点的DFT进一步分解为2个$\frac{N}{4}$点的 DFT。这两个$\frac{N}{4}$点DFT的输入也是将$\frac{N}{2}$点DFT的输入上下对半分开，通过蝶形运算而形成，情况和第一步分解相同。图4.4.2示出了这一步分解的过程。

<img src=".\fig\4.4.2.png" style="zoom:80%;" />

图4.4.2按频率抽取，将$N$点DFT分解为两个$\frac{N}{2}$点的DFT($N = 8$)

<img src=".\fig\4.4.3.png" style="zoom:80%;" />

图4.4.3 按频率抽取将$N$点DFT分解为4个$\frac{N}{4}$点的DFT($N = 8$)

这样的分解可一直进行下去，直到分解$v$步以后变成了求$\frac{N}{2}$个两点的DFT为止。而这$\frac{N}{2}$个两点DFT计算结果(共$N$个值)就是$x\left( n \right)$的$N$点DFT的结果$X\left( k \right)$。两点DFT实际上只有加减运算，为了比较及统一运算结构，我们仍然用一个系数为$W_N^0$的蝶形运算来表示。这样，按频率抽取的完整的FFT结构如图4.4.4所示(图中N = 8)。

<img src=".\fig\4.4.4.png" style="zoom:80%;" />

图4.4.4 N=8的频率抽取法FFT流图

### 4.4.2.    时间抽取算法与频率抽取算法的比较

比较图4.4.4与图4.3.5可知DIT与DIF两种算法存在着两点差别：

（1）DIF的输入正好是自然顺序，输出却是反序顺序，这与DIT的情况正好相反。但这并不是实质性差別，因为二者的输入输出顺序都能由自然顺序变为反序，或者相反。由于DIF输出是反序，所以运算完毕后，要经过“整序”变为自然顺序输出，整序的规律和时间抽取法相同。

（2）DIF的蝶形运算(图4.4.1)与DIT的蝶形运算(图4.3.1)略有不同，其差別在于DIF中复数乘法出现于减法运算之后。

DIT与DIF两种算法有很多相似之处：

（1）由图4.4.4可见，频率抽取法也共有$\nu $列运算。每列运算也需要$\frac{N}{2}$个蝶形运算来完成。因此也需要${m_F} = \frac{N}{2}{\log _2}N$次复乘和${a_F} = N{\log _2}N$次复加，计算量和时间抽取法是相等的。

（2）两种算法均可原位运算。

​		比较图4.3.5和图4.4.4不难看出二者互为转置。我们把图4.3.5反一个面并倒转信号流图的方向和交换输入与输出，即可从图4.3.5得到图4.4.4。同理，也可通过转置，从图4.4.4得到图4.3.5。概括地说:对于每一种按时间抽取的FFT算法都存在一种按频率抽取的算法，二者互为转置。

<img src=".\fig\4.4.5.png" style="zoom:50%;" />

图4.4.5 N=8的时间抽取法FFT流图

### 4.4.3.    离散傅里叶逆变换的快速算法（IFFT）

研究快速逆傅里叶变换算法，从IDFT公式

 $x\left( n \right) = \frac{1}{N}\sum\limits_{k = 0}^{N - 1} {X\left( k \right)W_N^{ - kn}}$  (4.4.7)

与DFT公式

$X\left( k \right) = \sum\limits_{n = 0}^{N - 1} {x\left( n \right)W_N^{nk}} $

比较可见，如果我们用$W_N^{ - 1}$代替${W_N}$，并将计算结果乘以$\frac{1}{N}$(常数$\frac{1}{N}$经常分解为${\left( {\frac{1}{2}} \right)^\nu }$并且在$\nu $列运算中每列都分别乘一个$\frac{1}{2}$因子)。这样，以上所讨论的按时间抽取或按频率抽取的FFT算法，都可以直接用来运算IDFT。例如，按照上述原则，我们可以直接由图4.4.4按频率抽取的FFT流图，得到图4.4.5的IFFT流图。当把时间抽取的FFT算法用于IFFT运算时，由于输入变量由时间序列$x\left( n \right)$改成了频率序列$X\left( k \right)$，因此原来按$x\left( n \right)$的奇偶次序分组的时间抽取法FFT，现在就成了按$X\left( k \right)$的奇偶次序抽取的IFFT，故应该称为频率抽取的IFFT。同样，频率抽取的FFT运用于IFFT时，也应该称为时间抽取的IFFT运算。

类似地，如果用${W_N}$代替$W_N^{ - 1}$，并且将输出乘上$N$，则快速傅里叶逆变换算法可用来计算快速傅里叶变换。所以把上面按时间抽取的IFFT流图4.4.5中$W_N^{ - k}$换为$W_N^k$每列都去掉因子$\frac{1}{2}$(等效于输出乘上$N$，同时注意图4.4.5中的$X\left( k \right)$现在则代表$x\left( n \right)$，图中的$x\left( n \right)$则应是代表$X\left( k \right)$。这样便由图4.4.5得到按频率抽取的由$x\left( n \right)$计算$X\left( k \right)$的图4.4.4。这也就是把图4.3.5转置后所得到的流图。

以上所讨论的IFFT算法，虽然编程序也很方便，但总要稍微改动FFT程序和参数才能实现。还有一种IFFT算法可以完全不用改动FFT程序。根据离散傅里叶逆变换的另一公式

 $x\left( n \right) = \frac{1}{N}{\left[ {\sum\limits_{k = 0}^{N - 1} {{X^*}\left( k \right)W_N^{kn}} } \right]^*} = \frac{1}{N}{\left\{ {DFT\left[ {{X^*}\left( k \right)} \right]} \right\}^*}$  (4.4.8)

如果，我们先将$X\left( k \right)$取共轭，即将$X\left( k \right)$的虚部乘以$ - 1$，就可直接访问FFT子程序。最后再对运算结果取一次共轭，并乘以$\frac{1}{N}$即得$x\left( n \right)$值。取共轭变换有内部函数可执行，这样FFT运算及IFFT运算都可以共用一个子程序块，因而在使用时是很方便的。

### 4.4.4.    按频率抽取的FFT算法的若干变体

根据前面讨论的时间抽取法和频率抽取法的关系可知，只要将转置处理应用于按时间抽取的FFT算法若干变体的流图，我们就得到了相应的按频率抽取的FFT算法若干变体的流图，这里不再赘述。

##               4.5 N为复合数的FFT算法——统一的FFT方法

上两节讨论了输入序列的列长为 $N = {2^\nu }$的情况。这在实际上使用得最多，因为基-2 FFT程序简单，效率很高，使用方便。

若列长不是$N = {2^\nu }$，则一般可有两种处理办法

1. 将$x\left( n \right)$用补零使$N$增长到最邻近的一个${2^\nu }$数值。例如$N = 30$，则在$x\left( n \right)$序列中补进$x\left( {30} \right) = x\left( {31} \right) = 0$两个零值点，使$N$达到${2^5} = 32$。由DFT的性质研究可知，有限长序列补零以后，并不影响其频谱$X\left( {{e^{j\omega }}} \right)$，只是频谱的采样点数增加了，例如由30点增加到32点。这在许多场合是无害的，但不是最节省的计算方法。
2. 如果要求准确的$N$点DFT值，而$N$又是不能再分解成因子的素数，则只能采用直接的DFT算法，或后面将要介绍的CZT方法。若$N$是一个复合数，即它可以分解成一些因子的乘积，则可以用FFT的统一算法，前面讨论的FFT算法仅是这种统一算法的特例。

### 4.5.1.    算法原理

要计算$N$点DFT是

 $X\left( k \right) = \frac{1}{N}\sum\limits_{k = 0}^{N - 1} {x\left( n \right)W_N^{nk}} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} k = 0,1, \cdots N - 1$  (4.5.1)

假定$N$是一复合数，$N = ML$，则可将$n$用下面公式表示

 $n = M{n_1} + {n_0}$  ${n_1} = 0,1,...L - 1$  ${n_0} = 0,1,...M - 1$  (4.5.2)

这是将原来信号的序号$n$表示为矩阵的形式，${n_0}$为列序号${n_1}$为行序号，$M$为列的数目，而$L$为行的数目。

通过下例可以看出，这种描述$n$的方法是正确的。例如$N = 12,M = 4,L = 3$，则可以把12个采样值序号$n$排成3行4列的矩阵形式。

例如$n = 6 = 1M + 2$，位于矩阵排列中的第一行${n_1} = 1$第二列${n_0} = 2$处，对于此列中任一采样值的序号$n$可写为

$\begin{array}{l}
n = 4{n_1} + {n_0}\\
{n_1} = 0,1,2,\\
{n_0} = 0,1,2,3
\end{array}$

所以

$\begin{array}{l}
n = \left\{ {{n_0},4 + {n_0},8 + {n_0}} \right\}\\
{\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt}  = \left\{ {0,1,2,3...11} \right\}{\kern 1pt} {\kern 1pt} 
\end{array}$  ${\kern 1pt} {n_0} = 0,1,2,3$

|                                                              | N=12排列为矩阵形式 | N=12排列为矩阵形式 | N=12排列为矩阵形式 | 表4.5.1 |
| :----------------------------------------------------------: | :----------------: | :----------------: | :----------------: | :-----: |
| ${n_1}{\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} n{\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {n_0}$ |         0          |         1          |         2          |    3    |
|                              0                               |         0          |         1          |         2          |    3    |
|                              1                               |         4          |         5          |         6          |    7    |
|                              2                               |         8          |         9          |         10         |   11    |

同理，对应的输出频谱序列的$k$值，也可用矩阵排列的形式表达为

$k = L{k_1} + {k_0}$  $\begin{array}{l}
{k_1} = 0,1,...M - 1\\
{n_0} = 0,1,...L - 1
\end{array}$  (4.5.3)

${k_1}$为变换后的列向量。${k_0}$为变换后的行变量。当按(4.5.3)式组合这些变量时，就得到单一变量。

对于$N = 12,M = 4,L = 3$的情况，则有

$\begin{array}{l}
k = 3{k_1} + {k_0}\\
{k_1} = 0,1,2,3\\
{k_0} = 0,1,2
\end{array}$

$\begin{array}{*{20}{c}}
{k = \left\{ {{k_0},3 + {k_0},6 + {k_0},9 + {k_0}} \right\}}\\
{ = 0,1,2, \cdots 11{\kern 1pt} {\kern 1pt} }
\end{array}{\kern 1pt} {\kern 1pt} {\kern 1pt} $  ${k_0} = 0,1,2{\kern 1pt} $

这样通过${n_0},{n_1},{k_0},{k_1}$可组合成$n$及$k$的从$0,1,2{\kern 1pt} , \cdots 11$直到$N - 1$的各个数。

将(4.5.2)式，(4.5.3)式代入(4.5.1)式则得

$\begin{array}{l}
X\left( k \right) = X\left( {L{k_1} + {k_0}} \right) = X\left( {{k_1},{k_0}} \right)\\
{\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt}  = \sum\limits_{n = 0}^{N - 1} {x\left( n \right)W_N^{nk}} \\
{\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt}  = \sum\limits_{{n_0} = 0}^{M - 1} {\sum\limits_{{n_1} = 0}^{L - 1} {x\left( {M{n_1} + {n_0}} \right)W_N^{\left( {M{n_1} + {n_0}} \right)\left( {L{k_1} + {k_0}} \right)}} } \\
{\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt}  = \sum\limits_{{n_0} = 0}^{M - 1} {\sum\limits_{{n_1} = 0}^{L - 1} {x\left( {{n_1},{n_0}} \right)W_N^{M{n_1}L{k_1}}} } W_N^{M{n_1}{k_0}}W_N^{{n_0}L{k_1}}W_N^{{n_0}{k_0}}\\
{\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt}  = \sum\limits_{{n_0} = 0}^{M - 1} {\sum\limits_{{n_1} = 0}^{L - 1} x } \left( {{n_1},{n_0}} \right)W_N^{M{n_1}{k_0}}W_N^{{n_0}{k_0}}W_N^{{n_0}L{k_1}}
\end{array}$  (4.5.4)

上面推到中运用了$W_N^{M{n_1}L{k_1}} = W_N^{N{n_1}{k_1}} = 1$的结果。

注意，为了计算出用${n_0},{n_1}$表示的$n$的所有位，(4.5.1)式中的单个求和现在必须用对${n_0},{n_1}$两个求和号来代替。$x({n_1},{n_0})$表示$x(n)$在$n$为${n_0},{n_1}$顺序排列时的情况，$X({k_1},{k_0})$则表示$X(k)$在$k$为${k_0},{k_1}$顺序排列时的情况。反之，$x({n_0},{n_1})$表示$x(n)$在$n$为${n_0},{n_1}$顺序排列时的情况，$X({k_0},{k_1})$则表示$X(k)$在$k$为${k_0},{k_1}$顺序排列时的情况。

下面进一步将(4.5.4)式分段表示

$\begin{array}{l}
X\left( {{k_1},{k_0}} \right) = \sum\limits_{{n_0} = 0}^{M - 1} {\left[ {\sum\limits_{{n_1} = 0}^{L - 1} x \left( {{n_1},{n_0}} \right)W_N^{M{n_1}{k_0}}} \right]}  \cdot W_N^{{n_0}{k_0}} \cdot W_N^{{n_0}L{h_1}}\\
{\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt}  = \sum\limits_{{n_0} = 0}^{M - 1} {\left\{ {\left[ {\sum\limits_{{n_1} = 0}^{L - 1} x \left( {{n_1},{n_0}} \right)W_L^{{n_1}{k_0}}} \right] \cdot W_N^{{n_0}{k_0}}} \right\}}  \cdot W_M^{{n_0}{k_1}}\\
{\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt}  = \sum\limits_{{n_0} = 0}^{M - 1} {\left\{ {{X_1}\left( {{k_0},{n_0}} \right)W_N^{{n_0}{k_0}}} \right\}} W_M^{{n_0}{k_1}}\\
{\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt}  = \sum\limits_{{n_0} = 0}^{M - 1} {X_1^\prime } \left( {{k_0},{n_0}} \right)W_M^{{n_0}{k_1}}\\
{\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt}  = {X_2}\left( {{k_0},{k_1}} \right)
\end{array}$  (4.5.5)

式中

${X_1}\left( {{k_0},{n_0}} \right) = \sum\limits_{{n_1} = 0}^{L - 1} x \left( {{n_1},{n_0}} \right)W_L^{{n_1}{k_0}}\qquad {k_0} = 0,1, \cdots L - 1$  (4.5.6)

表示${n_0}$为参变数$\left( {{n_0} = 0,1, \ldots ,M - 1} \right)$时的${n_1}$与${k_0}$之间的$L$点离散傅里叶变换（类似于离散傅里叶变换${X_1}\left( {{k_0}} \right) = \sum\limits_{{n_1} = 0}^{L - 1} {x\left( {{n_1}} \right)W_L^{{n_1}{k_0}}} ,{k_0} = 0,1, \ldots L - 1$的情况）。也即把每一列的数据(相应于${n_0}$为某一值)，对应不同的${k_0}$值作$L$点离散傅里叶变换。因${n_0}$共有$M$个值，${k_0}$共有$L$个值，故可求得$M{\rm{ \times }}L = N$个${X_1}\left( {{k_0}{n_0}} \right)$的序列值来。

$X_1\left( {{k_0},{n_0}} \right) = {X_1}\left( {{k_0},{n_0}} \right)W_N^{{n_0}{k_0}}$，表示(4.5.6)式的离散傅里叶变换乘子了因子$W_N^{{n_0}{k_0}}$所组成的$N$个新序列值。$W_N^{{n_0}{k_0}}$称为旋转因子，(twiddle factor)，或铰链因子。

${X_2}\left( {{k_0},{k_1}} \right) = \sum\limits_{{n_0} = 0}^{M - 1} {X_1^\prime } \left( {{k_0},{n_0}} \right)W_M^{{k_1}{r_0}}\qquad {k_1} = 0,1, \cdots M - 1$  (4.5.7)

表示${k_0}$为参变量$\left( {{k_0} = 0,1, \ldots L - 1} \right)$时的${k_{\rm{1}}}$和${n_0}$之间的$M$点离散傅里叶变换（类似于离散傅里叶变换${X_2}\left( {{k_1}} \right) = \sum\limits_{{n_0} = 0}^{M - 1} {{{X'}_1}\left( {{n_0}} \right)W_M^{{k_1}{n_0}}} ,{k_1} = 0,1, \ldots M - 1$的情况）。也即把行序号为${k_0}$的一行数据对应不同的${k_1}$值作$M$点DFT，从而可得$N = L{\rm{ \times }}M$个${X_2}\left( {{k_0},{k_1}} \right)$的频谱序列值。

(4.5.5)式还表明了所得结果${X_2}\left( {{k_0},{k_1}} \right)$是按${k_0}{k_1}$顺序排列的，可用$k = l{k_1} + {k_0}$式进行译序，从${X_2}\left( {{k_0},{k_1}} \right)$恢复出$X\left( k \right) = X\left( {{k_0},{k_1}} \right)$来。

### 4.5.2.    运算步骤

$N$为复合数$N = ML$的DFT算法的运算步骤可总结如下

（1）将$x\left( n \right)$改写成$x\left( {{n_1},{n_0}} \right)$改写的公式是$x\left( n \right) - x\left( {M{n_1} + {n_0}} \right) - x\left( {{n_1},{n_0}} \right)$，${n_1} = 0,1 \cdots L - 1$和${n_0} = 0,1 \cdots M - 1$，然后对$N$点的DFT进行分解。

（2）先对列作M$个$L$点的DFT

${X_1}\left( {{k_0},{n_0}} \right) = \sum\limits_{{n_1} = 0}^{M - 1} x \left( {{n_1},{n_0}} \right)W_L^{{k_0},{n_1}},\quad {k_0} = 0,1 \cdots L - 1$

（3）把$N$个${X_1}\left( {{k_0},{n_0}} \right)$乘以相应旋转因子$W_M^{{k_0},{n_0}}$成一个新的序列${X'_1}\left( {{k_0},{n_0}} \right)$。

（4）再对行作$L$个$M$点DFT

${X_2}\left( {{k_0},{k_1}} \right) = \sum\limits_{{n_0} = 0}^{M - 1} {{{X'}_1}} \left( {{k_0},{n_0}} \right)W_M^{k,{n_0}},\quad {k_1} = 0,1 \cdots M - 1$

(5) 进行译序

快速傅里叶变换的基本思想就是要将大点数DFT的运算尽量分为小点数的运算，所以上面的分解是可以减少运算工作量的。按照上述步骤所进行的$N = ML = 4 \times 3 = 12$的运算流图如图4.5.1 所示。图中只画出了部分点的情况，其余点的情况类似。

<img src=".\fig\4.5.1.png" style="zoom:50%;" />

图4.5.1 $N = M \times L = 4 \times 3 = 12$时的FFT运算流图

应该指出，还可以按相反的顺序来计算$X\left( k \right) = X\left( {L{k_1} + {k_0}} \right)$，即按下式所示的顺序计算$X\left( k \right)$与(4.5.4)式的计算顺序相比，除输入输出序列都需要进行译序外，不同的是(4.5.8)式的计算顺序为：

$X\left( {L{k_1} + {k_0}} \right) = \underbrace {\sum\limits_{{n_1} = 0}^{L - 1} {W_L^{{k_0}{n_1}}} \underbrace {\sum\limits_{{n_0} = 0}^{M - 1} {\underbrace {\left[ {x\left( {M{n_1} + {n_0}} \right)W_N^{{k_0}{n_0}}} \right]}_{\left( 1 \right)}W_M^{{k_1}{n_0}}} }_{\left( 2 \right)}}_{\left( 3 \right)}$  (4.5.8)

(1) 先把时间序列与旋转因子$W_N^{{k_0}{n_0}}$相乘；

(2) 计算每一行的$M$点离散傅里叶变换；

(3) 计算每一列的$L$点离散傅里叶变换。

(4.5.4)式的计算顺序是旋转因子在第一次变换运算后相乘，而(4.5.8)式的计算顺序是旋转因子在第一次变換运算前就先与时间序列相乘.这种旋转因子相乘的先后次序的不同，也反映在按时间抽取及按频率抽取的两点变换的蝶式算法中。前者是先乘$W_n^r$后作变换，后者是先作变换后乘$W_n^r$。

上面仅讨论了$N = ML$，即$N$只能被分解为两个数的情况。若$N$为一高度可分解的数，则可按上述方法连续地分解为小点数的DFT。如$N = ML$，而$L = PQ$，则$N = MPQ$。其流图不难由前面介绍的方法自行画出。这样，通过多次分解,一直分到最少点数的DFT，从而使运算得到最高效率。

### 4.5.3.    基数

上面谈到，$N = {2^v}$的FFT称为基-2FFT。基数这一术语，通常用来描述特定的分解。若$N$是一个复合数，则可分解为一些因子的乘积，且分解不是唯一的。例如$N = 60$就有以下几种分解：

$60 = 3 \times 4 \times 5 = 5 \times 4 \times 3 = 4 \times 3 \times 5 = 12 \times 5 = 2 \times 2 \times 5 \times 3$

因此，复合数一般可以表达成

$N = {r_1}{r_2} \cdots {r_m}$  (4.5.9)

特别当${r_1} = {r_2} =  \cdots  \cdots {r_m}$时，则$N = {r^m}$。这时可通过$m$级$r$点的DFT来实现$N$点FFT的运算。这种FFT算法称为基$r$算法。$r = 2$时的算法通常称为基-2算法。这就是在§4-3,§4-4中 介绍的FFT算法。$r = 4,8$时的算法，分别称为基-4，基-8算法。

假如$N$不能分解成几个相同数因子的乘积，如$N = 60 = 3 \times 4 \times 5 = 12 \times 5 = 2 \times 2 \times 5 \times 3$，则可分別进行3点，4点，5点的；或12点，5点的；或2点，2点，5点，3点的DFT来实现$N$点FFT运算。通常称这种算法为混合基算法。

由于在计算机中按$r = 2,4,8$时的算法进行运算可以取得更多的方便，因此它们受到特别重视。

### 4.5.4.    N为复合数的FFT运算量的估计

从$N$为复合数的FFT算法的计算步骤可知，若$N = LM$，则在三个步骤中需要作$M$个$L$点DFT，再把$N$个序列的值与旋转因子相乘，然后进行$L$个$M$点DFT。因此，当译序的运算量不计在内时，所需的运算量可估算如下

$M$个$L$点DFT的运算量：$\left\{ \begin{array}{l}
\text{复数乘法}--M{L^2}\\
\text{复数加法}--ML\left( {L - 1} \right)
\end{array} \right.$

乘$N$个$W_N^{{k_0}{n_0}}$因子需$N$次复数乘法。

$L$个$M$点DFT的运算量：$\left\{ \begin{array}{l}
\text{复数乘法}--L{M^2}\\
\text{复数加法}--LM\left( {M - 1} \right)
\end{array} \right.$

$N$为复合数的FFT的总运算量：$\left\{ \begin{array}{l}
\text{复数乘法}--M{L^2} + N + L{M^2} = N\left( {M + L + 1} \right)\\
\text{复数加法}--ML\left( {L - 1} \right) + LM\left( {M - 1} \right) = N\left( {M + L - 2} \right)
\end{array} \right.$

直接计算$N$点DFT的运算量：$\left\{ \begin{array}{l}
\text{复数乘法}--{N^2}\\
\text{复数加法}--N\left( {N - 1} \right)
\end{array} \right.$

因此，$N$为复合数的FFT及直接计算$N$点DFT，二者的乘法及加法运算量的比值(不计及${W^0}$…等的乘法节省)为

${R_ \times } = \frac{{N\left( {M + L + 1} \right)}}{{{N^2}}} = \frac{{M + L + 1}}{N}$  (4.5.10)

${R_ + } = \frac{{N\left( {M + L - 2} \right)}}{{N\left( {N - 1} \right)}} = \frac{{\left( {M + L - 2} \right)}}{{\left( {N - 1} \right)}}$  (4.5.11)

例如，当$N = 60 = 12 \times 5 = ML$时，$N$为复合数的FFT算法与$N$点直接算法的乘法运算量的比值为

${R_ \times } = \frac{{12 + 5 + 1}}{{60}} = \frac{{18}}{{60}}$  (4.5.12)

这时，前者算法的运算量只有后者算法运算量的三分之一弱。若$N$可分解成更多因子的话，比值还会进一步减小。



##                         4.6 分裂基FFT算法

### 4.6.1.    更快算法的要求

前曾指出，按基数2，4，8的FFT算法进行运算可取得更多的方便，因此受到特别重视。理论上讲用较大的基数可进一步减少运算次数，但程序(或硬件)都变得复杂，因此取大于8的基数没有多大实际意义。

在数论变换和维诺格拉德（Winograd）算法出现之初，人们曾寄以厚望，虽然在理论上不失为有意义的进展，但后来发现它们在实用上并不理想。目前，实用中多采用基本形式的基-2或基-4FFT算法。

1984年，法国杜梅尔（P.Douhamel）和霍尔曼（H.Hollmann）将基-2和基-4分解揉合 在一起，提出了一种分裂基FFT算法。其运算量比前述几种算法都有所减少，运算流图却与基-2FFT很接近，程序也很短，因此分裂基是一种实用、高效的算法。

### 4.6.2.    算法原理

设$N = Pq$，且$P = N/4$，$q = 4$，则n可表示为

$n = P{n_1} + {n_0} = \frac{N}{4}{n_1} + {n_0}\quad 0 \le {n_1} \le 3\quad 0 \le {n_0} \le \frac{N}{4} - 1$

$\begin{array}{l}
X(k) = \sum\limits_{n = 0}^{N - 1} {x\left( n \right)W_N^{kn}} \\
\quad \quad {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt}  = \sum\limits_{{n_0} = 0}^{N/4 - 1} {\sum\limits_{{n_1} = 0}^3 x } \left( {\frac{N}{4}{n_1} + {n_0}} \right)W_N^{k\left( {\frac{N}{4}{n_1} + {n_0}} \right)}\\
\quad \quad {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt}  = \sum\limits_{{n_0} = 0}^{N/4 - 1} {W_N^{k{n_0}}} \sum\limits_{{n_1} = 0}^3 x \left( {\frac{N}{4}{n_1} + {n_0}} \right)W_4^{k{n_1}}\\
\quad \quad {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt}  = \sum\limits_{{n_0} = 0}^{N/4 - 1} {\left[ {x\left( {{n_0}} \right)W_4^0 + x\left( {{n_0} + \frac{N}{4}} \right)W_4^k + x\left( {{n_0} + \frac{N}{2}} \right)W_4^{2k} + x\left( {{n_0} + \frac{{3N}}{4}} \right)W_4^{3k}} \right]W_N^{k{n_0}}} 
\end{array}$

在上面推导中运用了$W_N^{\frac{N}{4}{n_1}k} = W_4^{k{{\rm{n}}_1}}$的结果。

将k表示为

$k = 4{k_1} + {k_0}\qquad 0 \le {k_1} \le \frac{N}{4} - 1,\quad 0 \le {k_0} \le 3$

则$X(k)$可表示为

$\begin{array}{l}
X\left( k \right) = X\left( {4{k_1} + {k_0}} \right)\\
\quad \quad {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt}  = \sum\limits_{{n_0} = 0}^{N/4 - 1} {\left[ {x\left( {{n_0}} \right) + x\left( {{n_0} + \frac{N}{4}} \right)W_4^{\left( {4{k_1} + {k_0}} \right)} + x\left( {{n_0} + \frac{N}{2}} \right)W_4^{2\left( {4{k_1} + {k_0}} \right)} + x\left( {{n_0} + \frac{{3N}}{4}} \right)W_4^{3\left( {4{k_1} + {k_0}} \right)}} \right]} W_N^{\left( {4{k_1} + {k_0}} \right){n_0}}\\
\quad \quad {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt}  = \sum\limits_{{n_0} = 0}^{N/4 - 1} {\left[ {x\left( {{n_0}} \right) + x\left( {{n_0} + \frac{N}{4}} \right)W_4^{{k_0}} + x\left( {{n_0} + \frac{N}{2}} \right)W_4^{2{k_0}} + x\left( {{n_0} + \frac{{3N}}{4}} \right)W_4^{3{k_0}}} \right]} W_N^{\left( {4{k_1} + {k_0}} \right){n_0}}
\end{array}$

上面推导中$W_4^{l4{k_1}} = 1,l = 1,2,3$。在${k_0} = 0,1,2,3$时，用$k$表示${k_1}$，$n$表示${n_0}$，可得出

$\left\{ \begin{array}{l}
X(4k) = \sum\limits_{n = 0}^{N/4 - 1} {\left[ {x\left( n \right) + x\left( {n + \frac{N}{4}} \right) + x\left( {n + \frac{N}{2}} \right) + x\left( {n + \frac{{3N}}{4}} \right)} \right]} W_N^{4kn}\\
X(4k + 1) = \sum\limits_{n = 0}^{N/4 - 1} {\left[ {x\left( n \right) - jx\left( {n + \frac{N}{4}} \right) - x\left( {n + \frac{N}{2}} \right) + jx\left( {n + \frac{{3N}}{4}} \right)} \right]} W_N^{4kn + n}\\
X(4k + 2) = \sum\limits_{n = 0}^{N/4 - 1} {\left[ {x\left( n \right) - x\left( {n + \frac{N}{4}} \right) + x\left( {n + \frac{N}{2}} \right) - x\left( {n + \frac{{3N}}{4}} \right)} \right]} W_N^{4kn + 2n}\\
X(4k + 3) = \sum\limits_{n = 0}^{N/4 - 1} {\left[ {x\left( n \right) + {\rm{j}}x\left( {n + \frac{N}{4}} \right) - x\left( {n + \frac{N}{2}} \right) - jx\left( {n + \frac{{3N}}{4}} \right)} \right]} W_N^{4kn + 3n}
\end{array} \right.$  (4.6.1)

$0 \le k \le \frac{N}{4} - 1$

当$k$从0增加到$(N/4) - 1$时，上四式中的任一式均为频域$x\left( n \right)$的$N$点DFT变换值$X\left( k \right)$隔4点取1点的$N/4$点抽取，称为分裂基按频率抽取。因$X\left( {4k} \right)$和$X\left( {4k + 2} \right)$全为偶数序号处的$X\left( k \right)$值，合在一起应是隔2点取一点的$N/2$点的抽取，所以(4.6.1)式可写为如下形式

$\left\{ \begin{array}{l}
X\left( {2k} \right) = \sum\limits_{n = 0}^{N/2 - 1} {\left[ {x\left( n \right) + x\left( {n + \frac{N}{2}} \right)} \right]} W_N^{2kn}{\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} 0 \le k \le \frac{N}{2} - 1\\
X\left( {4k + 1} \right) = \sum\limits_{n = 0}^{N/4 - 1} {\left\{ {\left[ {\left( {x\left( n \right) - x\left( {n + \frac{N}{2}} \right)} \right) - {\rm{j}}\left( {x\left( {n + \frac{N}{4}} \right) - x\left( {n + \frac{{3N}}{4}} \right)} \right)} \right]W_N^n} \right\}} W_N^{4kn}\qquad \\
\qquad \qquad \qquad \qquad \qquad \qquad \qquad \qquad 0 \le k \le \frac{N}{4} - 1\\
X\left( {4k + 3} \right) = \sum\limits_{n = 0}^{N/4 - 1} {\left\{ {\left[ {\left( {x\left( n \right) - x\left( {n + \frac{N}{2}} \right)} \right) + {\rm{j}}\left( {x\left( {n + \frac{N}{4}} \right) - x\left( {n + \frac{{3N}}{4}} \right)} \right)} \right]W_N^{3n}} \right\}} W_N^{4kn}\\
\qquad \qquad \qquad \qquad \qquad \qquad \qquad \qquad 0 \le k \le \frac{N}{4} - 1
\end{array} \right.$  (4.6.2)

$\left\{ \begin{array}{l}
{x_2}\left( n \right) = x\left( n \right) + x\left( {n + \frac{N}{2}} \right)\qquad 0 \le n \le \frac{N}{2} - 1\\
x_4^1(n) = \left[ {\left( {x\left( n \right) - x\left( {n + \frac{N}{2}} \right)} \right) - {\rm{j}}\left( {x\left( {n + \frac{N}{4}} \right) - x\left( {n + \frac{{3N}}{4}} \right)} \right)} \right]W_N^n\\
x_4^2(n) = \left[ {\left( {x\left( n \right) - x\left( {n + \frac{N}{2}} \right)} \right){\rm{ + j}}\left( {x\left( {n + \frac{N}{4}} \right) - x\left( {n + \frac{{3N}}{4}} \right)} \right)} \right]W_N^n\\
\qquad \qquad \qquad \qquad \qquad \qquad \qquad 
\end{array} \right.\begin{array}{*{20}{c}}
{\begin{array}{*{20}{c}}
{}\\
{}
\end{array}}\\
{\begin{array}{*{20}{c}}
{}\\
{0 \le n \le \frac{N}{4} - 1}
\end{array}}\\
{}
\end{array}$  (4.6.3)

则(4.6.2)式可写成如下简明的形式

$\left\{ {\begin{array}{*{20}{c}}
{X\left( {2k} \right) = \sum\limits_{n = 0}^{N/2 - 1} {{x_2}} \left( n \right)W_N^{2nk} = {\mathop{\rm DFT}\nolimits} \left[ {{x_2}\left( n \right)} \right]{\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} \qquad 0 \le k \le \frac{N}{2} - 1}\\
{X\left( {4k + 1} \right) = \sum\limits_{N = 0}^{N/4 - 1} {x_4^1} \left( n \right)W_N^{4kn} = {\mathop{\rm DFT}\nolimits} \left[ {X_4^1\left( n \right)} \right]{\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} 0 \le k \le \frac{N}{4} - 1}\\
{X\left( {4k + 3} \right) = \sum\limits_{N = 0}^{N/4 - 1} {x_4^2} \left( n \right)W_N^{4kn} = {\mathop{\rm DFT}\nolimits} \left[ {X_4^2\left( n \right)} \right]{\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} 0 \le k \le \frac{N}{4} - 1}
\end{array}} \right.$  (4.6.4)

由此可见，一个$N$点的DFT计算可分解为计算一个$N/2$点DFT，两个$N/4$点DFT。这种分解既有基-2部分，又有基-4部分。基-2部分$X\left( {2k} \right)$的奇数点部分又进一步分解为基-4抽取分解；而基-4部分的偶数点部分又进一步分解为基-2抽取分解。对应$N$点序列按分裂基算法的第一次分解的流图如图4.6.1所示。可见，由$x(n),x(n + N/4),x(n + N/2),x(n + 3N/4)$4个点求出用于计算一个$N/2$点DFT和两个$N/4$点DFT的4个输入值的运算流图的形状像“$L$”字母，所以称为$L$形蝶形。一个$L$形蝶形中只有两次乘旋转因子运算，其余全为加减法运算。因为$N/4$点DFT共有$N/4$个输入数据，所以这种$L$形共有$N/4$个。图中只画出其中一个$L$形。

<img src=".\fig\4.6.1.png" style="zoom:50%;" />

图4.6.1分裂基算法第一次分解L形流图

$N/2$点DFT又可用$N/8$个$L$形蝶形计算分解成一个$N/4$点DFT和两个$N/8$点DFT。两个$N/4$点DFT也可以分别用$N/16$个$L$形蝶形计算分解为一个$N/8$点DFT和两个$N/16$点DFT。循此进行，最后分解为4点或2点DFT，都易于算出。下面以$N = 16$为例，说明完整的分裂基FFT的运算流图。

据(4.6.3)式，$N = 16$时的第一次抽取分解时，则有

$\left\{ \begin{array}{l}
{x_2}\left( n \right) = x\left( n \right) + x\left( {n + 8} \right)\qquad 0 \le n \le 7\\
x_4^1\left( n \right) = \left\{ {\left[ {x\left( n \right) - x\left( {n + 8} \right)} \right] - j\left[ {x\left( {n + 4} \right) - x\left( {n + 12} \right)} \right]} \right\}W_{16}^n\quad 0 \le n \le 3\\
x_4^2\left( n \right) = \left\{ {\left[ {x\left( n \right) - x\left( {n + 8} \right)} \right] + j\left[ {x\left( {n + 4} \right) - x\left( {n + 12} \right)} \right]} \right\}W_{16}^{3n}\quad 0 \le n \le 3
\end{array} \right.$

把上式结果代入(4.6.4)式可得

$\left\{ {\begin{array}{*{20}{l}}
{X\left( {2k} \right) = DFT\left[ {{x_2}\left( n \right)} \right]}&{0 \le k \le 7}\\
{X\left( {4k + 1} \right) = DFT\left[ {x_4^1\left( n \right)} \right]}&{0 \le k \le 3}\\
{X\left( {4k + 3} \right) = DFT\left[ {x_4^2\left( n \right)} \right]}&{0 \le k \le 3}
\end{array}} \right.$

根据上述两组表示式可画出如图4.6.2所示的第一次分解的$L$形运算流图

<img src=".\fig\4.6.2.png" style="zoom:50%;" />

图4.6.2     16点分裂基第一次分解$L$形流图

第二次分解

先对图4-22中的$N/2$点DFT进行分解

令

${X_1}\left( l \right) = X\left( {2l} \right)$，则据(4.6.4)式，第二次分解有

$\left\{ {\begin{array}{*{20}{c}}
{{X_1}\left( {2l} \right) = DFT\left[ {{y_2}\left( n \right)} \right]{\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} 0 \le l \le 3}\\
{{X_1}\left( {4l + 1} \right) = DFT\left[ {y_4^1\left( n \right)} \right]{\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} 0 \le l \le 1}\\
{{X_1}\left( {4l + 3} \right) = DFT\left[ {y_4^2\left( n \right)} \right]{\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} 0 \le l \le 1}
\end{array}} \right.$

由(4.6.3)式，第二次分解时可得

$\left\{ {\begin{array}{*{20}{l}}
{{y_2}\left( n \right) = {x_2}\left( n \right) + {x_2}\left( {n + 4} \right)}&{0 \le n \le 3}\\
{y_2^1\left( n \right) = \left\{ {\left[ {{x_2}\left( n \right) - {x_2}\left( {n + 4} \right)} \right] - j\left[ {{x_2}\left( {n + 2} \right) - {x_2}\left( {n + 6} \right)} \right]} \right\}W_8^n}&{n = 0,1}\\
{y_1^2\left( n \right) = \left\{ {\left[ {{x_2}\left( n \right) - {x_2}\left( {n + 4} \right)} \right] + j\left[ {{x_2}\left( {n + 2} \right) - {x_2}\left( {n + 6} \right)} \right]} \right\}W_8^{3n}}&{n = 0,1}
\end{array}} \right.$

由上式可画出对应图4.6.2中的$N/2$点DFT分解的$L$形流图如图4.6.3所示。

按同法可以画出4点分裂基FFT的$L$形运算流图如图4.6.4所示。

<img src=".\fig\4.6.4.png" style="zoom:50%;" />

图4.6.4 4点分裂基L形运算流图

用图4.6.4取代图4.6.2和图4.6.3中的4点DFT(当然要用原图中的输入和输出序列)，例如取图4.6.4中的输入输出序列为

$\nu \left( l \right) = {y_2}\left( l \right)\qquad V\left( k \right) = {X_1}\left( {2k} \right) = X\left( {4k} \right)$

<img src=".\fig\4.6.3.png" style="zoom:50%;" />

图4.6.3 图4.6.2中的N/2点DFT分解的L形流图

即$V\left( 0 \right)$、$V\left( {\rm{2}} \right)$、$V\left( 1 \right)$和$V\left( 3 \right)$顺次变为$X\left( 0 \right)$、$X\left( 8 \right)$、$X\left( 4 \right)$和$X\left( {12} \right)$。再用图4.6.3取代图4.6.2中的$N/2$点的DFT。即得如图4.6.5所示的完整的16点分裂基FFT算法流图。上面所得的和$V\left( k \right)$相对应的4点$X\left( k \right)$，正是图4.6.5中的前四个输出值。

<img src=".\fig\4.6.5.png" style="zoom:50%;" />

图4.6.5 16点分裂基按频率抽取的FFT算法流图

(图中各支路上箭头均已略去)

由图可见，分裂基FFT算法结构同基-2FFT算法结构相似，适用于$N = {2^M}$的情况，由$M$级运算实现。运算流图输入为顺序，输出为反序。由于$L$形蝶形的特殊结构，使程序实现比基-2或基-4算法稍复杂些。

### 4.6.3.    分裂基FFT算法的运算量

观察图4.6.5可以看出，$N$点分裂基FFT的全部复乘次数是运算流图中$L$形个数的2倍，而复加次数与基-2FFT算法相同为$N{\log _2}N$。只要求出各级运算中$L$形形蝶形的个数，即可求得全部复乘次数。

设第$j$级有${l_j}$个$L$型蝶形$j = 1,2, \cdots ,M - 1,M = {\log _2}N$

则有

$\begin{array}{l}
{l_1} = \frac{N}{4}\\
{l_j} = \frac{N}{4} - \frac{{{l_{j - 1}}}}{2}{\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} j = 2, \cdots M - 1{\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} 
\end{array}$  (4.6.5)

其中第二式来自$L$型蝶形的特殊结构，由图4-21可知，第$j - 1$列中的$L$型蝶形包含了在次一列（第$j$列）中的一部分结点的计算，所占结点数刚好等于第$j - 1$列中所有$L$形蝶形对应结点的一半，所以第$j$列$L$型蝶形的个数就减少了${l_{j - 1}}/2$个。由(4.6.5)式可知

${l_1} = \frac{N}{4}$

${l_2} = \frac{N}{4} - \frac{{{l_1}}}{2} = \frac{N}{4}\left( {1 - \frac{1}{2}} \right)$

${l_3} = \frac{N}{4} - \frac{{{l_2}}}{2} = \frac{N}{4}\left( {1 - \frac{1}{2} + \frac{1}{4}} \right)$

$ \vdots $

${l_j} = \frac{N}{4}{\sum\limits_{i = 0}^{j - 1} {\left( { - \frac{1}{2}} \right)} ^i} = \frac{N}{6}\left[ {1 - {{\left( { - \frac{1}{2}} \right)}^j}} \right]$

因每个$L$型蝶形有两次复乘运算，所以全部复乘次数为

${C_M} = 2\sum\limits_{j = 1}^{M - 1} {{l_j}}  = \frac{N}{3}\left[ {M - \frac{2}{3} + \frac{2}{3}{{\left( { - \frac{1}{2}} \right)}^M}} \right] = \frac{1}{3}N{\log _2}N - \frac{{2N}}{9} + {\left( { - 1} \right)^M}\frac{2}{9}$  (4.6.6)

与基-2FFT算法的复数乘数相比，$N{\log _2}N$前的系数由1/2变为1/3,仅这一项就使复乘次数下降33%。当然在具体实现时还有其它因素的影响，尤其是在软件实现时循环变量的判断和转向语句上的耗费较多，未必得益太多；但在设计专用集成电路芯片时仍有其潜力，这方面已有人作了探索。

##                        4.7 实序列的FFT算法

### 4.7.1.    问题的提出

以上讨论的FFT算法都是复数运算，包括序列$x\left( n \right)$也认为是复数。但是大多数场合，信号是实数序列。任何实数都可看作虚部为零的复数。例如，要求某实信号的复谱，我们可以人为地将实信号加上数值为零的虚部变成复信号，再用FFT来求其离散傅里叶变换。一个$N$点的实序列只有$N$个自由变量，而一个$N$点的复序列却有$2N$个自由变量。所以按照上面所述的那样去做，读者一定会认为这是很不经济的，因为把实序列变为复序列，存储器要增加一倍， 且计算机在程序执行中，即使虚部为零，仍要进行涉及虚部的乘法运算。一种解决办法是设计一个专门用于实数据的FFT，但是在信息处理系统中复数据FFT是必不可少的，再编一个实数据FFT似无必要。下面介绍的两种办法可利用复数据FFT对实数据进行有效的计算。

### 4.7.2.    一个N点FFT同时运算两个N点实序列

这种方法的基本原理在第三章关于DFT的奇偶对称特性中已简单介绍过，现进一步说明如下设${x_1}\left( n \right)$，${x_2}\left( n \right)$是彼此独立的$N$点实序列，它们的离散傅里叶变换分别为

${X_1}\left( k \right) = DFT\left[ {{x_1}\left( n \right)} \right]$

${X_2}\left( k \right) = DFT\left[ {{x_2}\left( n \right)} \right]$

${X_1}\left( k \right)$，${X_2}\left( k \right)$值可以通过FFT运算一次获得。首先我们将${x_1}\left( n \right)$，${x_2}\left( n \right)$分别当做一复序列的实部和虚部，即令

$x\left( n \right) = {x_1}\left( n \right) + j{x_2}\left( n \right)$  (4.7.1)

然后通过FFT运算可以获得$x\left( n \right)$的DFT值：

$\begin{array}{l}
X\left( k \right) = DFT\left[ {x\left( n \right)} \right]\\
{\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt}  = DFT\left[ {{x_1}\left( n \right)} \right] + jDFT\left[ {{x_2}\left( n \right)} \right]\\
{\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\rm{ =  }}{X_1}\left( k \right) + j{X_2}\left( k \right)
\end{array}$  (4.7.2)

根据第三章中有关复数序列的特性，我们知道

${X_1}\left( k \right) = {X_{ep}}\left( k \right) = \frac{1}{2}\left[ {X\left( k \right) + {X^*}\left( {N - k} \right)} \right]$  (4.7.3)

${X_2}\left( k \right) =  - j{X_{op}}\left( k \right) =  - j\frac{1}{2}\left[ {X\left( k \right) - {X^*}\left( {N - k} \right)} \right]$  (4.7.4)

即将$x\left( n \right)$的FFT运算结果$x\left( k \right)$，通过(4.7.3)式，(4.7.4)式分别求出$x\left( k \right)$的周期性共轭对称分量${X{ep}}\left( k \right)$和周期性共轭反对称分量${X{op}}\left( k \right)$，也就得到了独立的${X_1}\left( k \right)$及${X_2}\left( k \right)$值。

### 4.7.3.    一个N点的FFT运算一个2N点的实序列 

设$x\left( n \right)$是$2N$点的实序列，我们人为地将$x\left( n \right)$分为偶数组${x_1}\left( n \right)$和奇数组${x_2}\left( n \right)$

$\begin{array}{*{20}{c}}
{{x_1}\left( n \right) = x\left( {2n} \right)}&{n = 0,1, \cdots N - 1}
\end{array}$  (4.7.5)

$\begin{array}{*{20}{c}}
{{x_2}\left( n \right) = x\left( {2n + 1} \right)}&{n = 0,1, \cdots N - 1}
\end{array}$  (4.7.6)

然后将${x_1}\left( n \right)$及${x_2}\left( n \right)$组成一个复数序列

$y\left( n \right) = {x_1}\left( n \right) + j{x_2}\left( n \right)$

通过$N$点FFT运算可得到

$\begin{array}{l}
Y\left( k \right) = DFT\left[ {y\left( n \right)} \right]\\
{\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt}  = DFT\left[ {{x_1}\left( n \right)} \right] + jDFT\left[ {{x_2}\left( n \right)} \right]\\
{\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt}  = {X_1}\left( k \right) + j{X_2}\left( k \right)
\end{array}$

根据前面讨论的(4.7.3)式，(4.7.4)式我们得到

$\begin{array}{l}
{X_1}\left( k \right) = DFT\left[ {{x_1}\left( n \right)} \right] = \frac{1}{2}\left[ {Y\left( k \right) + {Y^ * }\left( {N - k} \right)} \right]\\
{X_2}\left( k \right) = DFT\left[ {{x_2}\left( n \right)} \right] =  - j\frac{1}{2}\left[ {Y\left( k \right) - {Y^ * }\left( {N - k} \right)} \right]
\end{array}$  (4.7.7)

我们要求的是$2N$点的实序列了$x\left( n \right)$所对应的$X\left( k \right)$，为此需求$X\left( k \right)$与${X_1}\left( k \right)$，${X_2}\left( k \right)$的关系。

$\begin{array}{l}
{X_1}\left( k \right) = DFT\left[ {x\left( {2n} \right)} \right] = \sum\limits_{n = 0}^{N - 1} {x\left( {2n} \right)} W_N^{nk} = \sum\limits_{n = 0}^{N - 1} {x\left( {2n} \right)} W_{2N}^{2nk}\\
{X_2}\left( k \right) = DFT\left[ {x\left( {2n + 1} \right)} \right] = \sum\limits_{n = 0}^{N - 1} {x\left( {2n + 1} \right)} W_N^{nk} = \sum\limits_{n = 0}^{N - 1} {x\left( {2n + 1} \right)} W_{2N}^{2nk}
\end{array}$

$\begin{array}{l}
X\left( k \right) = \sum\limits_{n = 0}^{2N - 1} {x\left( n \right)W_{2N}^{nk}} \\
{\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt}  = \sum\limits_{n = 0}^{N - 1} {x\left( {2n} \right)} W_{2N}^{2nk} + \sum\limits_{n = 0}^{N - 1} {x\left( {2n + 1} \right)} W_{2N}^{\left( {2n + 1} \right)k}\\
{\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt}  = \sum\limits_{n = 0}^{N - 1} {x\left( {2n} \right)} W_{2N}^{2nk} + W_{2N}^k\sum\limits_{n = 0}^{N - 1} {x\left( {2n + 1} \right)} W_{2N}^{2nk}
\end{array}$

因此可得

$X\left( k \right) = {X_1}\left( k \right) + W_{2N}^k{X_2}\left( k \right)\begin{array}{*{20}{c}}
{}&{0 \le k \le 2N - 1}
\end{array}$

或

$\left\{ {\begin{array}{*{20}{c}}
{X\left( k \right) = {X_1}\left( k \right) + W_{2N}^k{X_2}\left( k \right)}&{}\\
{X\left( {k + N} \right) = {X_1}\left( k \right) - W_{2N}^k{X_2}\left( k \right)}&{}
\end{array}} \right.0 \le k \le N - 1$  (4.7.8)

这样，由${x_1}\left( n \right)$和${x_2}\left( n \right)$组成复序列$y\left( n \right)$，经FFT运算求得$Y\left( k \right)$，再经(4.7.7)式及(4.7.8)式的两级蝶形运算求得$X\left( k \right)$，从而达到了用一个点的FFT(对$y\left( n \right)$进行FFT运算)，计算了一个$2N$点的实序列$x\left( n \right)$。这时总共需要

复乘数  ${m_{2F}} = \frac{N}{2}{\log _2}N + 2N = \frac{N}{2}\left( {4 + {{\log }_2}N} \right)$

复加数  ${a_{2F}} = N{\log _2}N + 4N = N\left( {4 + {{\log }_2}N} \right)$

直接用$2N$点的FFT，则需要

复乘数  ${m_{2N}} = N{\log _2}2N = N\left( {1 + {{\log }_2}N} \right)$

复加数  ${a_{2N}} = 2N{\log _2}2N = 2N\left( {1 + {{\log }_2}N} \right)$

因此可以节省乘法和加法的倍数分别为：

$\frac{{{m_{2N}}}}{{{m_{2F}}}} = \frac{{2\left( {1 + {{\log }_2}N} \right)}}{{\left( {4 + {{\log }_2}N} \right)}}$

$\frac{{{a_{2N}}}}{{{a_{2F}}}} = \frac{{2\left( {1 + {{\log }_2}N} \right)}}{{\left( {4 + {{\log }_2}N} \right)}}$

当$N$很大时，可节省近一倍的工作量。

## 4.8 线性调频Z变换(Chirp Z Transform)算法

### **4.8.1.** 问题的提出

上面介绍的$ N $点**DFT**的快速算法，即有限长序列$ x\left( n \right) $的z变换$ X\left( z \right) $,在z平面单位圆上等间隔采样点$ {z_k} $处的采样值$ X\left( {{z_k}} \right) $的快速算法，它要求N为高度复合的数。

实际中也许对其它围线上的z变换采样发生兴趣，或者并不需要计算整个单位圆上Z变换的采样，或者要求能有效地计算当$ N $是素数时序列的**DFT**。因此提高计算**DFT**的灵活性是非常有意义的。线性调频$ z $变换（简称CZT）就是适用于这种更为一般情況下由$ x\left( n \right) $求$ X\left( {{z_k}} \right) $的快速变换。

### **4.8.2.** 算法原理

已知$ x\left( n \right) $,$ 0 \le n \le N - 1 $,则它的$ z $变换是

| $ X\left( z \right) = \sum\limits_{n = 0}^{N - 1} {x\left( n \right)} {z^{ - n}} $ |      | (4.8.1) |
| ------------------------------------------------------------ | ---- | ------- |
|                                                              |      |         |

为适应$ z $可以沿$ z $平面内更一般的路径取值，可令$ z $的采样点$ {z_k} $为

|      | $ \begin{array}{*{20}{c}}{{z_k} = A{W^{ - k}},}&{k = 0,1 \cdots M - 1}\end{array} $ | (4.8.2) |
| ---- | ------------------------------------------------------------ | ------- |
|      |                                                              |         |

$ M $表示欲分析的复频谱的点数，不一定等于$ N $。$ A $和$ W $都是任意复数，即

|      | $ A = {A_0}{{\rm{e}}^{j{\theta _0}}} $  | (4.8.3) |
| ---- | --------------------------------------- | ------- |
|      | $ W = {W_0}{{\rm{e}}^{ - j{\phi _0}}} $ | (4.8.4) |

将上两式代入(4.8.2)式得

|      | $ {z_k} = \left( {{A_0}{{\rm{e}}^{j{\theta _0}}}} \right)\left( {{W_0}^{ - k}} \right)\left( {{{\rm{e}}^{jk{\phi _0}}}} \right) $ | (4.8.5) |
| ---- | ------------------------------------------------------------ | ------- |
|      |                                                              |         |

因此有

|      | $ \begin{array}{l}{z_0} = {A_0}{{\rm{e}}^{j{\theta _0}}}\\{z_1} = {A_0}W_0^{ - 1}{{\rm{e}}^{j\left( {{\theta _0} + {\phi _0}} \right)}}\\{z_k} = {A_0}W_0^{ - k}{{\rm{e}}^{j\left( {{\theta _0} + k{\phi _0}} \right)}}\\{z_{M - 1}} = {A_0}W_0^{ - \left( {M - 1} \right)}{{\rm{e}}^{j\left[ {{\theta _0} + \left( {M - 1} \right){\phi _0}} \right]}}\end{array} $ |      |
| ---- | ------------------------------------------------------------ | ---- |
|      |                                                              |      |

采样所沿的周线如图4.8.1所示。由以上所述可见：

1) $ {A_0} $表示起始采样点$ {z_0} $的矢量半径长度，通常$ {A_0} \le 1 $，否则$ {z_0} $将处于单位圆$ \left| z \right| = 1 $的外部。
2) $ {\theta _0} $表示起始采样点$ {z_0} $的相角(即角频率)，它可是正值或负值。
3) $ {\Phi _0} $表示两相邻$ {z_k} $点之角频率差，它也可是正值或负值。当$ {\Phi _0} $为负时表示$ {z_k} $的路径是顺时针旋转的,当$ {\Phi _0} $为正时，表示$ {z_k} $的路径是逆时针旋转的。
4) $ {W_0} $的大小控制着周线盘旋是向内弯曲还是向外弯曲。$ {W_0} < 1 $，则随着$ k $的增加，周线盘旋向外弯曲，$ {W_0} > 1 $，则随着$ k $的增加，周线向原点盘旋; $ {W_0} = 1 $，表示半径为$ {A_0} $的一段圆弧，$ {A_0} = 1 $，这段圆弧则是单位圆的一部分。

 

当满足下面的特殊条件：

1) $ M = N $ 
2) $ A = {A_0}{{\rm{e}}^{j{\theta _0}}} = 1 $(即$ {{A_0} = 1,{\theta _0} = {0^ \circ }} $)
3) $ W = {W_0}{{\rm{e}}^{ - j{\phi _0}}} = {{\rm{e}}^{ - j\frac{{2\pi }}{N}}} $（即$ {{W_0} = 1,{\Phi _0} = \frac{{2\pi }}{M} = \frac{{2\pi }}{N}} $），就恢复到$ {z_k} $是均匀地等角度地分布于全部$ \left| z \right| = 1 $单位圆上的情况，即变为求该序列的DFT。$X\left( z \right)$

 

<img src=".\fig\4.8.1.png" style="zoom:50%" />

图4.8.1线性调频Z变换的z平面周线

将代入(4.8.1)式得到

|      | $X\left( {{z_k}} \right) = \sum\limits_{N = 0}^{N - 1} x \left( n \right){A^{ - n}}{W^{nk}}$ | (4.8.6) |
| ---- | ------------------------------------------------------------ | ------- |
|      |                                                              |         |

就是在给定的更为一般的轨迹上的取值。利用布鲁斯坦（Bluestein)所提出的等式

|      | $nk = \frac{1}{2}\left[ {{n^2} + {k^2} - {{\left( {k - n} \right)}^2}} \right]$ |      |
| ---- | ------------------------------------------------------------ | ---- |
|      |                                                              |      |

(4.8.6)式可写成

|      | $\begin{array}{l}X\left( {{z_k}} \right) = \sum\limits_{n = 0}^{N - 1} x \left( n \right){A^{ - n}} \cdot {W^{\frac{{{n^2}}}{2}}} \cdot {W^{ - \frac{{{{\left( {k - n} \right)}^2}}}{2}}} \cdot {W^{\frac{{{k^2}}}{2}}}\\{\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt}  = {W^{\frac{{{k^2}}}{2}}} \cdot \sum\limits_{n = 0}^{N - 1} {\left[ {x\left( n \right){A^{ - n}}{W^{\frac{{{n^2}}}{2}}}} \right]} {W^{ - \frac{{{{\left( {k - n} \right)}^2}}}{2}}}\end{array}$ |         |
| ---- | ------------------------------------------------------------ | ------- |
| 令   | $f\left( n \right) = x\left( n \right){A^{ - n}} \cdot {W^{\frac{{{n^2}}}{2}}}\quad n = 0,1, \cdots N - 1$ | (4.8.7) |
|      | $h(n) = {W^{ - \frac{{{n^2}}}{2}}}$                          | (4.8.8) |
| 则   | $X\left( {{z_k}} \right) = {W^{\frac{{{k^2}}}{2}}}\sum\limits_{n = 0}^{N - 1} f \left( n \right)h\left( {k - n} \right)\quad k = 0,1, \cdots M - 1$ | (4.8.9) |

由上式可见，${z_k}$点的$ z $变换值$X\left( {{z_k}} \right)$通过求$f\left( n \right)$与$h\left( n \right)$的离散卷积值，并乘上${W^{{k^2}/2}}$得到， 即通过FIR实现了频谱分析。这里$f\left( n \right)$与$h\left( n \right)$的离散卷积可以用$f\left( n \right)$和$h\left( n \right)$的适当段[见(4.8.12)式]的圆周卷积来实现，而圆周卷积可用FFT的方法求得。(4.8.9)式可用图4.8.2所示的一个线性系统来表示，当${W_0} = 1$时，系统的单位采样响应为

|      | $h\left( n \right) = {W^{ - \frac{{{n^2}}}{2}}} = {\left( {{{\rm{e}}^{j{\Phi _0}}}} \right)^{\frac{{{n^2}}}{2}}}$ | (4.8.10) |
| ---- | ------------------------------------------------------------ | -------- |
|      |                                                              |          |

序列$h\left( n \right)$为复指数序列，其角位移$\frac{{{n^2}{\Phi _0}}}{2}$对时间序列数$ n $的微分值为$ n{\Phi _0} $，相当于角频率。因此其频率随序数$ n $成线性增长，在雷达系统中这样的信号称作线性调频信号（chirp signal），所以这种算法称为线性调频$ z $变换。

<img src=".\fig\4.8.2.png" style="zoom:50%" /> 

图4.8.2 CZT的运算流程

### **4.8.3.** CZT的实现步骤

由图4.8.2所示的CZT谱分析法的运算流程，可列出CZT运算的步骤如下：

1) 根据已知的$A\left( { = {A_0}{{\rm{e}}^{j{\theta _0}}}} \right)$和$W\left( { = W{{\rm{e}}^{ - j{\Phi _0}}}} \right)$，即由已知的$ {A_0} $，$ {\theta _0} $，$ {W_0} $，$ {\Phi _0} $求出${A^{ - n}}{W^{{n^2}/2}}$，$ (0 \le n \le N - 1) $的各值，将这些数值与欲分析的信号$ x\left( n \right){\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} (0 \le n \le N - 1) $相乘，即得$ f\left( n \right) $ ，$ 0 \le n \le N - 1 $。如图4.8.3(a)，(b)所示。
2) 选择一个最小的数L，使其满足$ L > (N + M - 1) $，同时又满足$L = {{\rm{2}}^m}$ ，以便用基-2 FFT 算法来求得$ f\left( n \right) $与$h\left( n \right)$的卷积。
3) 釆用补零的方法将(1)中所得的$h\left( n \right)$变为序列。

|      | $ f\left( n \right) = \left\{ {\begin{array}{*{20}{l}}{{A^{ - n}} \cdot {W^{\frac{{{n^2}}}{2}}}x\left( n \right)}&{0 \le n \le N - 1}\\0&{N \le n \le L - 1}\end{array}} \right. $ | (4.8.11) |
| ---- | ------------------------------------------------------------ | -------- |
|      |                                                              |          |

并用FFT方法求此序列的离散傅里叶变换

|      | $F\left( r \right) = \sum\limits_{n = 0}^{L - 1} f \left( n \right){{\rm{e}}^{ - j\frac{{2\pi }}{L}rn}}\quad 0 \le r \le L - I$ |      |
| ---- | ------------------------------------------------------------ | ---- |
|      |                                                              |      |

其图形如图4.8.3(**c**)所示。

4) 为了使$ f\left( n \right) $与$ h\left( n \right) $的圆周卷积与$ f\left( n \right) $，$ h\left( n \right) $的线性卷积等效，并且根据要求，我们只对$ k = (0\ ~M - 1) $ 范围的卷积结果感兴趣，这样就要把$ h\left( n \right) $取出适当的一段。注意，(4.8.8)式的序列长度并未明确规定，只是规定了其函数关系为$h\left( n \right) = {W^{ - {n^2}/2}}$。所谓适当，是指取出的区间应为$ ( - N + l\ ~M - { \rm{ }}1) $，当$ N + M - 1 < L $时，则需补零或其它任意序列，但应补在$  - N + l $点之外。按上述要求定义的列长为**L**的序列$ h\left( n \right) $为

|      | $ h(n) = \left\{ {\begin{array}{*{20}{c}}{{W^{ - \frac{{{n^2}}}{2}}}}&{0 \le n \le M - 1}\\{{W^{\frac{{ - {{(L - n)}^2}}}{2}}}}&{L - N + 1 \le n \le L - 1}\\{}&{}\\{任意}&{M \le n \le L - N}\end{array}} \right. $ | (4.8.12) |
| ---- | ------------------------------------------------------------ | -------- |
|      |                                                              |          |

序列${W^{ - {n^2}/2}}$和$ h\left( n \right) $如图4.8.3(d)和(e)所示。为适应圆周卷积的要求，可认为上式所定义的$ f\left( n \right) $是以L为周期的周期序列的主值序列。

对(4.8.6)式定义的序列，取**L**点的DFT(当然也用FFT完成)

|      | $H\left( r \right) = \sum\limits_{n = 0}^{L - 1} h \left( n \right){e^{ - j\frac{{2\pi }}{L}rn}}{\rm{  }}0 \le r \le L - 1$ |      |
| ---- | ------------------------------------------------------------ | ---- |
|      |                                                              |      |

$ H(r) $示于图4.8.3(f )。

5) 将列长为**L**的二序列$ F\left( r \right) $和$ H\left( r \right) $逐点相乘所得到的是列长仍为**L**的序列$ G\left( r \right) = F\left( r \right)H\left( r \right) $，如图4.8.3(g)所示。再对序列$ G\left( r \right) $作**L**点离散傅里叶反变换得$ g\left( k \right) $，如图4.8.3(h)所示，这就是$ f\left( n \right) $与$ h\left( n \right) $的圆周卷积。此圆周卷积是按$ L( \ge N + M - 1) $点作的，$ f\left( n \right) $的列长仅为**N**，当$ h\left( n \right) $按(4.8.12)式取出时，$ f\left( n \right) $与$ h\left( n \right) $圆周卷积的前**M**个等于$ f\left( n \right) $与$ h\left( n \right) $的卷积结果的点，恰恰就是我们所需求的$ g\left( k \right) $的范围，$ g\left( k \right) $在$ k \ge M $之后的值没有意义可以不必去求。
6) 根据(4.8.9)式，将所得的$ g\left( k \right) $，$ 0 \le k \le M - 1 $，乘以系数${W^{{k^2}/2}}$，即得所要求的**M**个$ X\left( {{z_k}} \right) $值如图4.8.3(i)所示。

<img src=".\fig\4.8.3.png" style="zoom:50%" /> 

图4.8.3 CZT的波形图

### **4.8.4.** CZT运算置的估算

利用CZT算法求比直接求$ X\left( {{z_k}} \right) $的算法有效得多。这可从比较两种算法总共所需的乘法次数看出。整个CZT流程所需的乘法运算如下

1) 形成$f\left( n \right) = {A^{ - n}}{W^{{n^2}/2}}x\left( n \right)\;\:\left( {0 \le n \le N - 1} \right)$需要**N**次复乘。系数${A^{ - n}}{W^{{n^2}/2}}$可事先计算好并预存在存储器内。为了节约存储容量，这个系数也可用下式递推产生。

|      | ${A^{ - (n + 1)}}{W^{\frac{{{{(n + 1)}^2}}}{2}}} = \left( {{A^{ - n}}{W^{\frac{{{n^2}}}{2}}}} \right){W^n}{W^{\frac{1}{2}}}{A^{ - 1}}$ | (4.8.13) |
| ---- | ------------------------------------------------------------ | -------- |
|      |                                                              |          |

若令，

|      | ${C_n} = {A^{ - n}}{W^{\frac{{{n^2}}}{2}}}$             | (4.8.14) |
| ---- | ------------------------------------------------------- | -------- |
|      | ${D_n} = {W^n}{W^{\frac{1}{2}}}{A^{ - 1}} = {W^n}{D_0}$ | (4.8.15) |

 (这里，${D_0} = {W^{1/2}} \cdot {A^{ - 1}}$，并且$ {C_0} = 1 $)，则(4.8.13)式的递推关系可写为

|      | $\begin{array}{l}{C_{n + 1}} = {A^{ - \left( {n + 1} \right)}}{W^{\frac{{{{\left( {n + 1} \right)}^2}}}{2}}} = \left( {{A^{ - n}}{W^{\frac{{{n^2}}}{2}}}} \right)\left( {{W^n}{W^{\frac{1}{2}}}{A^{ - 1}}} \right)\\{\rm{         =  }}{C_n} \cdot {D_n}\end{array}$ | (4.8.16) |
| ---- | ------------------------------------------------------------ | -------- |
|      |                                                              |          |

所以只要预存好${D_0} = \frac{{\sqrt {{W_0}} }}{{{A_0}}}{e^{ - j\left( {\frac{{{\Phi _0}}}{2} + {\theta _0}} \right)}}$，便可利用(4.8.15)式，(4.8.16)式递推求出$ N $个系数${A^{ - n}}{W^{{n^2}/2}}$，结果是

|      | $ \begin{array}{*{20}{l}}\begin{array}{l}{C_0} = 1\\{C_1} = {C_0}{D_0} = {D_0}\\{C_2} = {C_1}{D_1} = {C_1}W{D_0} = W{D_0}^2\end{array}\\{{C_3} = {C_2}{D_2} = W{D_0}2{W^2}{D_0} = {W^3}{D_0}^3 \ldots  \ldots }\end{array} $ |      |
| ---- | ------------------------------------------------------------ | ---- |
|      |                                                              |      |

2) 由$ f\left( n \right) $求$F\left( r \right)$需作L点FFT，约需$\frac{L}{2}{\log _2}L$次复乘运算。
3) $ h\left( n \right) $可用(1)中所述方法递推求得，则由$ h\left( n \right) $用FFT方法计算$ H\left( r \right) $需要$\frac{L}{2}{\log _2}L$次复乘。假如保持**M**及**N**不变，$ h\left( n \right) $及$ H\left( r \right) $都可事先算好存入内存，这就不需要运算操作。
4) $ F\left( r \right) $与$ H\left( r \right) $相乘需要L次复乘运算。
5) 由$ G\left( r \right) $ 进行快速傅里叶逆变换需要$\frac{L}{2}{\log _2}L$次复乘。
6) 形成M点的输出$X\left( {{z_k}} \right) = g\left( k \right){W^{{k^2}/2}},(0 \le k \le M - 1)$，需做M次复乘。

综上所述，CZT总的乘法运算量约为$\frac{2}{3}L{\log _2}L + N + L + M$次复乘

因此运算量比例于$ L\log 2L{\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} (L \ge N + M - 1) $，而对*N*点的序列$ h\left( n \right) $直接计算*M*点的**Z变换**值$ X({z_k}) $ 的算法，则需要*MN*次复乘。在*M**、**N*足够小时，直接算法的运算量少，但当*M**，**N*值都大于50时，CZT算法比直接算法的运算量要少得多。

### **4.8.5.** CZT算法的特点

与标准FFT算法相比，CZT算法有以下特点：

1) 输入序列列长*N*及输出序列列长*M*不需要相等。
2) *N*及*M*不必是高度合成数，二者均可为素数。
3) ${z_k}$点的角间隔$ {\Phi _0} $是任意的，因此频率分辨率也是任意的。
4) 周线不必是**z**平面上的圆，在语音分析中螺旋形周线具有某些优点。
5) 起始点$ {z_0} $可任意选定，因此可从任意频率上开始对输入数据进行窄带的高分辨率的分析。
6) 若$ A = 1 $，$ M = N $，$W = {{\rm{e}}^{j\frac{{2\pi }}{N}}}$，则可用CZT来计算DFT，即使*N*为素数时也可以。这是 CZT算法应用的一个特例。

总之，CZT算法具有很大的灵活性，在某种意义上说，它是一个一般化的DFT。

除了上面介绍的DFT的快速算法外尚有用戈泽尔（Goertzel）算法及布鲁斯坦算法进行快速傅里叶变换计算的方法，限于篇幅这里就不作介绍了。

## 4.9 快速傅里叶变换的应用

凡是可以利用傅里叶变换来进行分析、综合、变换……的地方，都可以利用FFT算法及运用数字计算技术来加以实现。FFT在数字通信，语音信号处理，图像处理，匹配滤波以及功率谱估算、仿真、系统分析、雷达理论、光学及数值分析等各个领域都得到了广泛的应用，我们不可能对它们进行详细介绍。不管FFT在哪里应用，一般都以卷积积分或相关积分的具体处理为依据，或者以用FFT作为连续傅里叶变换的近似为基础。如果我们详细考察了这两种FFT的基本应用，就可以说我们已掌握了一般FFT应用的基本原理。对这两种基本的应用没有彻底的了解，想应用FFT解决像数字滤波、系统分析等问题就是空谈。

第三章讨论了离散傅里叶变换在连续傅里叶变换计算中的应用。由于FFT只是快速计算离散傅里叶变换的一种方法，所以我们已经研究了FFT作为连续傅里叶变换近似的基本应用原理。剩下的问题是介绍应用FFT来计算卷积和相关的技术。应用DFT计算卷积和相关的基本原理已在第三章中作了介绍，现在只是用FFT来计算相应函数的DFT，或用IFFT计算IDFT就可以了。以前曾预料用频域关系计算卷积或相关都是不现实的，因为需要增加大量的乘法次数。然而，由于应用FFT，计算速度得到了极大的提高，使很多在时域难以实时数字处理的工作，通过FFT绕道频域得以实现，因而应用频域分析的优点便突出了。

### 4.9.1. 利用FFT求卷积——快速卷积

1．用FFT求有限长序列间的卷积及求有限长序列与一很长序列的卷积

为方便以后的应用及问题的讨论,现将用FFT进行离散卷积的步骤归纳于下：

1) 设$x\left( n \right)$的列长为${N_1}$，$h\left( n \right)$的列长为${N_2}$，要求

|      | $y\left( n \right) = x\left( n \right) \otimes h\left( n \right) = \sum\limits_{k = 0}^{N - 1} {x\left( k \right)h{{\left( {\left( {n - k} \right)} \right)}_N}{R_N}\left( n \right)}  = \sum\limits_{k = 0}^{N - 1} {x\left( k \right)h\left( {n - k} \right)} $ | (4.10.1) |
| ---- | ------------------------------------------------------------ | -------- |
|      |                                                              |          |

2) 为使两有限长序列的线性卷积可用其圆周卷积来代替而不产生混淆，必须选择$N \ge {N_1} + {N_2} - 1$。为使用基-2FFT来完成卷积计算，故要求$N = {2^v}$（$v$是整数)。用补零的办法使具有列长为$N$，即

$x\left( n \right) = \left\{ {\begin{array}{*{20}{l}}
{x\left( n \right)}&{n = 0,1, \cdots ,{N_1} - 1}\\
0&{n = {N_1},{N_1} + 1 \cdots N - 1}
\end{array}} \right.$

$h\left( n \right) = \left\{ {\begin{array}{*{20}{l}}
{h\left( n \right)}&{n = 0,1, \cdots ,{N_2} - 1}\\
0&{n = {N_2},{N_2} + 1, \cdots N - 1}
\end{array}} \right.$

3) 为用圆周卷积定理(3.5.15)式计算线性卷积，先用FFT计算$x\left( n \right),h\left( n \right)$的$N$点离散傅里叶变换

|      | $x\left( n \right) $${FFT}$$X\left( k \right)$ | (4.10.2) |
| ---- | ---------------------------------------------- | -------- |
|      | $h\left( n \right)$${FFT}$$H\left( k \right)$  | (4.10.3) |

4) 组成乘积

|      | $Y\left( k \right) = X\left( k \right)H\left( k \right)$ | (4.10.4) |
| ---- | -------------------------------------------------------- | -------- |
|      |                                                          |          |

5) 用IFFT计算的$Y(k)$离散傅里叶逆变换得到线性卷积$y\left( n \right)$。由于

|      | $y\left( n \right) = \sum\limits_{k = 0}^{N - 1} {\left[ {\frac{1}{N}Y\left( k \right)} \right]W_N^{ - nk}}  = {\left[ {\sum\limits_{k = 0}^{N - 1} {\left[ {\frac{1}{N}{Y^*}\left( k \right)} \right]W_N^{nk}} } \right]^ * }$ | (4.10.5) |
| ---- | ------------------------------------------------------------ | -------- |
|      |                                                              |          |

可见，$y\left( n \right)$可由求的IFFT得到，也可以利用求$\frac{1}{N}{Y^*}\left( k \right)$的FFT再取共轭得到。

我们看到单一的线性卷积方程(4.10.1)式，现在用(4.10.2)式，(4.10.3)式，(4.10.4)式，和(4.10.5)式所代替。这样的计算虽然在频域上兜了一大圈，但因FFT算法计算效率很高，这四个公式实际上使卷积的计算更加快速。(4.10.1)式求$N$个采样值的卷积$y(n)$，需要的计算时间正比于${N^2}$(指乘法次数)。FFT的计算时间正比于$N{\log _2}N$，于是(4.10.2)式，(4.10.3)式，(4.10.5)式的总计算时间正比于$3N{\log _2}N$，(4.10.4)式的计算时间正比于$N$,所以应用FFT通过(4.10.2)式至(4.10.5)式计算线性卷积，一般说，比直接用(4.10.1)式计算要快些。究竟快多少，取决于点数、FFT的细节和所使用的卷积程序。

当信号$x\left( n \right)$很长时,$h\left( n \right)$仍为有限长序列，求此两序列的卷积，可采用第三章提到的分段卷积的办法(当然用FFT去完成)。

**2．*****\*高效的FFT卷积\****

FFT算法是对复输入函数设计的，采用FFT算法过滤实序列信号，算法的虚部就被浪费掉。为此，应设法提高使用效率。设$g\left( n \right)$，$s\left( n \right)$，$h\left( n \right)$是三组$N$点实序列，它们的$N$点DFT顺次为$G\left( k \right),S\left( k \right),H\left( k \right)$。可以用一次FFT运算同时实现以下两个卷积

|      | $\left\{ {\begin{array}{*{20}{c}}{{y_1}\left( n \right) = g\left( n \right) \otimes h\left( n \right)}\\{{y_2}\left( n \right) = s\left( n \right) \otimes h\left( n \right)}\end{array}} \right.$ | (4.10.6) |
| ---- | ------------------------------------------------------------ | -------- |
|      |                                                              |          |

方法是先将$g\left( n \right)$和$s\left( n \right)$组合成一个复数序列$p\left( n \right)$ 

|      | $p\left( n \right) = g\left( n \right) + js\left( n \right)$ | (4.10.7) |
| ---- | ------------------------------------------------------------ | -------- |
|      |                                                              |          |

则            

|      | ${\mathop{\rm DFT}\nolimits} \left[ {p\left( n \right)} \right] = P\left( k \right) = G\left( k \right) + jS\left( k \right)$ |      |
| ---- | ------------------------------------------------------------ | ---- |
|      |                                                              |      |

令                           

|      | $Y\left( k \right) = H\left( k \right){\rm{ }}p\left( k \right)$ | (4.10.8) |
| ---- | ------------------------------------------------------------ | -------- |
|      |                                                              |          |

然后用IFFT运算求出$y\left( n \right)$，它是$p\left( n \right)$与$h\left( n \right)$的圆周卷积值

|      | $\begin{array}{l}y\left( n \right) = IFFT\left[ {Y\left( k \right)} \right]\\{\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt}  = p\left( n \right) \otimes h\left( n \right)\\{\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt}  = \left[ {g\left( n \right) + js\left( n \right)} \right] \otimes h\left( n \right)\\{\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt}  = g\left( n \right) \otimes h\left( n \right) + js\left( n \right) \otimes h\left( n \right)\end{array}$ | (4.10.9) |
| ---- | ------------------------------------------------------------ | -------- |
|      |                                                              |          |

因此同时得到两个实序列的圆周卷积值

|      | $\left\{ {\begin{array}{*{20}{c}}{{y_1}\left( n \right) = g\left( n \right) \otimes h\left( n \right) = {\mathop{\rm Re}\nolimits} \left[ {y\left( n \right)} \right]}\\{{y_2}\left( n \right) = s\left( n \right) \otimes h\left( n \right) = {\mathop{\rm Im}\nolimits} \left[ {y\left( n \right)} \right]}\end{array}} \right.$ | (4.10.10) |
| ---- | ------------------------------------------------------------ | --------- |
|      |                                                              |           |

这种同时处理两组实序列卷积的方法，可有三种不同的实际使用：

1) 一个系统同时通过两种输入信号

设以$h\left( n \right)$表示系统的单位采样响应，而以$g\left( n \right)$表示输入信号${x_1}\left( n \right)$，$s\left( n \right)$表示输入信号${x_2}\left( n \right)$，和上面的处理方法相同，最后可由(4.10.10)式得到

|      | $\left\{ {\begin{array}{*{20}{c}}{{y_1}\left( n \right) = {x_1}\left( n \right) \otimes h\left( n \right) = {\mathop{\rm Re}\nolimits} \left[ {y\left( n \right)} \right]}\\{{y_2}\left( n \right) = {x_2}\left( n \right) \otimes h\left( n \right) = {\mathop{\rm Im}\nolimits} \left[ {y\left( n \right)} \right]}\end{array}} \right.$ |      |
| ---- | ------------------------------------------------------------ | ---- |
|      |                                                              |      |

2) 一个系统同时处理长序列分段过滤中的两个片段

仍设$h\left( n \right)$表示系统的单位采样响应，并令$g\left( n \right)$表示输入片段${x_i}\left( n \right)$，$s\left( n \right)$表示输入片段${x_{i + 1}}\left( n \right)$，即

|      | $p\left( n \right) = {x_i}\left( n \right) + j{x_{i + 1}}\left( n \right)$ |      |
| ---- | ------------------------------------------------------------ | ---- |
|      |                                                              |      |

这样系统对两个片段的过滤结果为

|      | $\left\{ {\begin{array}{*{20}{c}}{{y_i}\left( n \right) = {\mathop{\rm Re}\nolimits} \left[ {y\left( n \right)} \right]}\\{{y_{i + 1}}\left( n \right) = {\mathop{\rm Im}\nolimits} \left[ {y\left( n \right)} \right]}\end{array}} \right.$ |      |
| ---- | ------------------------------------------------------------ | ---- |
|      |                                                              |      |

当然，相应于所用的分段方法，还必须按3.5节中做法，适当合并所得结果。

3) 一个信号同时通过两个系统

令$g\left( n \right)$，$s\left( n \right)$分别代表两个系统的单位采样响应${h_1}\left( n \right)$，${h_2}\left( n \right)$，而以$h\left( n \right)$代表输入信号$x\left( n \right)$，则据(4.10.7)至(4.10.10)式的分析可得信号$x(n)$通过两系统的输出为

|      | $\left\{ {\begin{array}{*{20}{c}}{{y_1}\left( n \right) = x\left( n \right) \otimes {h_1}\left( n \right) = {\mathop{\rm Re}\nolimits} \left[ {y\left( n \right)} \right]}\\{{y_2}\left( n \right) = x\left( n \right) \otimes {h_2}\left( n \right) = {\mathop{\rm Im}\nolimits} \left[ {y\left( n \right)} \right]}\end{array}} \right.$ |      |
| ---- | ------------------------------------------------------------ | ---- |
|      |                                                              |      |

### 4.9.2.利用FFT求相关——快速相关

互相关及自相关的运算已广泛地应用于信号分析与统计分析，应用于连续时间系统也用于离散时间系统。

用FFT计算相关函数，称为快速相关，它与快速卷积完全类似，所不同的是一个应用圆周相关定理，利用圆周相关来等效线性相关。另一个应用圆周卷积定理，利用圆周卷积等效线性卷积，这时同样都要注意到离散傅里叶变换固有的周期性，也同样要用补零的办法来避免混叠。

利用FFT求相关的计算步骤如下

(1) 设$x\left( n \right)$列长为${N_1}$，$y\left( n \right)$列长为${N_1}$，要求线性相关

|      | $z\left( n \right) = \sum\limits_{k = 0}^{N - 1} {{x^*}\left( k \right)y\left( {n + k} \right)} $ | (4.10.11) |
| ---- | ------------------------------------------------------------ | --------- |
|      |                                                              |           |

(2) 为了使两个有限长序列的线性相关可用其圆周相关代替不产生混淆现象，因而可用 FFT及IFFT计算(4.10.11)式，我们选择周期$N$满足$N \ge {N_1} + {N_2} - 1$,且$N = {2^v}$ ($v$为整数)。用补零的办法使$x\left( n \right)$，$y\left( n \right)$，具有列长为$N$,即

|      | $\begin{array}{l}x\left( n \right) = \left\{ {\begin{array}{*{20}{l}}{x\left( n \right)}&{n = 0,1, \cdots ,{N_1} - 1}\\0&{n = {N_1},{N_1} + 1 \cdots N - 1}\end{array}} \right.\\y\left( n \right) = \left\{ {\begin{array}{*{20}{l}}{y\left( n \right)}&{n = 0,1, \cdots ,{N_2} - 1}\\0&{n = {N_2},{N_2} + 1, \cdots N - 1}\end{array}} \right.\end{array}$ |      |
| ---- | ------------------------------------------------------------ | ---- |
|      |                                                              |      |

(3) 为利用圆周相关定理(3.5.27)式计算线性相关，先用FFT计算$x\left( n \right)$,$y\left( n \right)$的$N$点离散傅里叶变换

|      | $x\left( n \right)$${FFT}$ $X\left( k \right)$ | (4.10.12) |
| ---- | ---------------------------------------------- | --------- |
|      | $y\left( n \right)$$ {FFT} Y\left( k \right)$  | (4.10.13) |

(4) 将$X\left( k \right)$的虚部${\mathop{\rm Im}\nolimits} \left[ {X\left( k \right)} \right]$改变符号，求得其共轭${X^*}\left( k \right)$。

(5) 组成乘积

|      | $z\left( k \right) = {X^*}\left( k \right)Y\left( k \right)$ | (4.10.14) |
| ---- | ------------------------------------------------------------ | --------- |
|      |                                                              |           |

(6) 对$z\left( k \right)$作IFFT,即得相关序列$z\left( n \right)$。同样由于

|      | $z\left( n \right){\rm{ }} = \sum\limits_{k = 0}^{N - 1} {\left[ {\frac{1}{N}z\left( k \right)} \right]} W_N^{ - nk} = {\rm{ }}{\left[ {\sum\limits_{k = 0}^{N - 1} {\left[ {\frac{1}{N}{z^*}\left( k \right)} \right]} W_N^{nk}} \right]^*}$ | (4.10.15) |
| ---- | ------------------------------------------------------------ | --------- |
|      |                                                              |           |

可见，由$z(k)$的IFFT求$z(n)$,可以利用求$\frac{1}{N}{Z^*}\left( k \right)$的FFT再取共轭得到。

如果$x\left( n \right) = y\left( n \right)$,则求得的$z(n)$是自相关序列。

(4.10.11)式至(4.10.15)式的计算时间，实质上和方程(4.10.1)式至(4.10.5)式的计算时间是一样的，可以应用上面分析快速卷积计算时间的结果及所得结论。

## 4.10 快速傅里叶变换的进展

自1965年快速傅里叶变换出现以来，除了前面介绍的各种DFT的快速算法外，也出现了一些新算法。比较好的和受到重视的是1975年7月美国IBM公司的雪米尔.维络格勒德（Shmuel Winograd）博士提出的维络格勒德傅里叶变换算法（Winograd Fourier Transform Algorithm），简称WFTA。维络格勒德应用数论推导出2,3,4,5,7,8,9和16点DFT的结果，称为“小N因子”的DFT。在计算一个变换长度为“大N”因子的DFT时，可先将“大N”分解为若干“小N”因子的连乘,再利用“小N”因子的DFT，就可得到一个“大N”的WFTA。例如，利用16,9,7,5四个“小N”因子的DFT，最多可算至5040点（$16 \times 9 \times 7 \times 5$）的DFT，一般情况下，这一长度是够用了。

WFTA算法的优点在于乘法次数较上几节讲的FFT大约减少了五分之四，加法的次数一般则与FFT差不多。由于有些计算机不能提供复数双精度计算，而WFTA全部是纯数（实数或虚数）运算。避免了复数运算，故WFTA程序有很好的通用性。

WFTA程序结构比FFT复杂的多，虽然运算速度一般比FFT快，但程序的编译时间比 FFT长，故从整个时间上看，不一定节省多少。不过如用硬件实现WFTA，其优越性就大为明显了。

分裂基FFT算法，其运算量比本章介绍的其它算法有所减少，运算流图与基—2FFT很接近，也是一种实用高效的新算法。

在FFT影响下，人们开始对广义的快速变换发生了强烈兴趣，进行了深入研究，出现了一系列快速变换，如快速沃尔什变换，快速数论变换等。各种快速变换已成为数字信号处理的基本技术，但与快速傅里叶变换相比，这些变换都有局限性。